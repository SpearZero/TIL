## 간단한 비즈니스 로직 구현

### 트랜잭션 스크립트
- 트랜잭션 스크립트 패턴은 프로시저를 기반으로 시스템의 비즈니스 로직을 구성하며, 각 프로시저는 퍼블릭 인터페이스를 통해 시스템 사용자가 실행하는 작업을 구현한다.
    - 시스템의 퍼블릭 오퍼레이션은 캡슐화의 경계로 사용한다.

### 구현
- 각 프로시저는 간단하고 쉬운 절차지향 스크립트로 구현
- 프로시저가 구현해야 하는 유일한 요구사항은 트랜잭션 동작
    - 각 작업은 성공하거나 실패할 수 있지만, 유효하지 않은 상태를 만들면 안된다.
    - 트랜잭션 스크립트 실행이 실패하더라도 시스템은 오류가 발생할 때까지 변경사항을 롤백하거나 보상 조치를 실행하여 일관성을 유지해야 한다.

### 트랜잭션 스크립트를 올바르게 구현하지 못해 발생하는 데이터 손상의 사례

#### 트랜잭션 동작 구현 실패
전체를 아우르는 트랜잭션 없이 여러 업데이트를 하는 경우
```C#
public class LogVisit {

    public void Execute(Guid userId, DateTime visitedOn) {
        _db.Execute(유저 테이블 마지막 방문 날짜 UPDATE)
        _db.Execute(방문 테이블 로그 INSERT)
    }
}
```
- UPDATE 후, INSERT 전에 문제가 발생하면 시스템이 일관되지 않은 상태이다.
    - User 테이블은 업데이트 되지만, VisitLog 테이블에는 레코드가 기록되지 않음

해결법
```C#
public class LogVisit {

    public void Execute(Guid userId, DateTime visitedOn) {
        try {   
            _db.StartTransaction();
            ... 업데이트 후 인서트
            _db.Commit();
        } catch {
            _db.Rollback();
            throw;
        }
    }
}
```
- 관계형 데이터베이스에서 기본으로 지원하는 기능을 활용해서 여러 레코드에 걸친 트랜잭션을 쉽게 구현할 수 있다.

#### 분산 트랜잭션
- 분산트랜잭션에서 통합할 수 없는 여러 개의 저장 장치로 작업하는 경우 상황이 복잡해진다.

```C#
// 데이터를 변경한 다음 메시지 버스에 메시지를 발행하여 시스템의 다른 컴포넌트에 변경사항을 알림
public class LogVisit {
    public void Execute(Guid userId, DateTime visitedOn) {
        _db.Execute(유저 테이블 마지막 방문날짜 UPDATE)
        _messageBus.Publish("VISITS_TOPIC", 방문 토픽 발생)
    }
}
```
- 테이블 업데이트 후 메시지 발행이 실패하는 경우 다른 컴포넌트는 메시지 발행 실패 알림을 받지 못한다.
- 여러 저장 장치에 걸쳐 있는 분산 트랜잭션은 복잡하고 확장하기 어렵고 오류가 발생하기 쉬우므로 일반적으로 피하는 방식
- CQRS, 아웃박스 패턴 등을 사용하면 해결이 가능하다.

#### 암시적 분산 트랜잭션
```C#
public class LogVisit {
    public void Execute(Guid userId) {
        _db.Execute(메서드 호출시 방문 카운트 1 증가)
    }
}
```
- 메서드는 하나의 데이터베이스에 있는 하나의 테이블에서 하나의 값을 업데이트

하지만 위의 경우도 잠재적으로 일관성 없는 상태로 이어질 수 있음
- 클라이언트 <-> LogVisit <-> 데이터베이스
    - 분산 트랜잭션을 구성함
- Execute는 void 타입이다.
    - 실패한 경우 클라이언트는 예외를 전달한다.
- 메서드가 성공했지만 클라이언트에게 결과를 전달하는데 실패하는 경우
    - LogVisit이 REST 서비스 일부이고 네트워크 중단 발생
    - 클라이언트가 LogVisit 작업의 성공적인 실행을 추적하기 전에 프로세스가 실패

해결방법
- 작업을 멱등성(idempotent)으로 만들기
    - 같은 요청을 여러 번 반복하더라도 결과를 동일하게 만든다.
        - 예를 들어 사용자에게 동일한 카운터 값을 요청하도록 전달
- 낙관적 동시성 제어 사용
    - 클라이언트가 처음 읽은 값과 동일한 경우에만 카운터 값을 업데이트

#### 트랜잭션 스크립트를 사용하는 경우
- 비즈니스 로직이 단순한 절차적 작업처럼 매우 간단한 문제 도메인에 효과적
- 비즈니스 로직이 단순한 지원 하위 도메인에 적합
- 일반 하위 도메인과 같은 외부 시스템과 연동하기 위한 어댑터로 사용하거나 충돌 방지 계층의 일부로 사용

트랜잭션 스크립트 패턴의
- 장점 : 단순하다
- 단점 : 비즈니스 로직이 복잡할수록 트랜잭션 간에 비즈니스 로직이 중복되기 쉽고 결과적으로 중복된 코드가 동기화되지 않을 때 일관성이 없는 동작 발생
    - 핵심 하위 도메인에서 사용하면 안된다.

### 액티브 레코드
- 비즈니스 로직이 단순한 경우 사용
- 좀 더 복잡한 자료구조에서도 비즈니스 로직이 작동할 수 있다.

#### 구현
- 액티브 레코드라는 전용 객체를 사용하여 복잡한 자료구조를 표현한다.
    - 뿐만 아니라 CRUD도 구현한다.
        - 따라서 ORM 또는 다른 데이터 접근 프레임워크와도 관련이 있음
- 트랜잭션 스크립트로 시스템의 비즈니스 로직을 만든다.
- 데이터베이스에 직접 접근하는 대신 트랜잭션 스크립트가 액티브 레코드 객체를 조작한다.

```C#
public class CreateUser {

    public void Execute(userDetails) {
        try {
            _db.StartTransaction();
            var user = new User();
            user.Name = userDetails.Name;
            user.Email = userDetails.Email;
            user.Save();
            _db.Commit();
        } catch {
            _db.Rollback();
            throw;
        }
    }
}
```
- 객체를 데이터베이스 스키마에 매핑하는 복잡성을 숨긴다.
- 영속성 외에도 객체에 비즈니스 로직이 포함될 수 있다.
    - 유효성 검사, 객체의 데이터 조작 등
- 액티브 레코드 객체의 고유한 기능
    - 자료구조와 동작(비즈니스 로직)의 분리

#### 액티브 레코드를 사용하는 경우
- CRUD 작업과 같은 비교적 간단한 비즈니스 로직에 사용
- 지원 하위 도메인, 일반 하위 도메인과 외부 솔루션의 연동, 모델 변환 작업에 적합
- 복잡한 자료구조를 데이터베이스 스키마에 매핑하는 복잡성을 해소

#### 실용적인 접근 방식
데이터의 무결성도 중요하지만 실용적인 접근 방식이 바람직한 경우가 존재한다.
- 수십억 개의 이벤트를 수집하는 시스템에서 이벤트의 0.001%가 중복되거나 손실되는 일은 '무시' 할 수 있다.
    - 위험하지 않거나 비즈니스에 큰 영향이 없는 경우

### 결론
- 트랜잭션 스크립트
    - 간단하고 쉬운 절차지향 스크립트로 구성
    - 작업이 성공하거나 실패하도록 보장
    - ETL처럼 단순한 비즈니스 로직을 가진 지원 하위 도메인에 적합
- 액티브 레코드
    - 간단한 CRUD 데이터 접근 방법을 제공하는 자료구조