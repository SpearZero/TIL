## 복잡한 비즈니스 로직 다루기

### 도메인 모델
- 복잡한 비즈니스 로직을 다루기 위한 것
- CRUD 인터페이스 대신 복잡한 상태전환을 다룬다.
- 항상 보호해야 하는 규칙인 비즈니스 규칙과 불변성을 다룬다.

#### 구현
도메인 모델
- 행동(behavior)과 데이터(data) 모두를 포함하는 도메인의 객체 모델
- 애그리게이트, 밸류 오브젝트, 도메인 이벤트, 도메인 서비스는 모두 객체 모델의 구성 요소이다.
    - 비즈니스 로직을 최우선으로 두는 공통 관심사가 있다.

#### 복잡성
- 모델에는 데이터베이스 또는 외부 시스템 구성요소의 호출 같은 인프라 또는 기술적 관심사를 피해야 한다.
- 플레인 올드 오브젝트(plain old object)
    - 인프라 구성 요소 또는 프레임워크에 의지하지 않고 직접 협업하지 않으면서 비즈니스 로직을 구현하는 객체

#### 유비쿼터스 언어
이 패턴은 코드에서 유비쿼터스 언어를 사용하게 하고 도메인 전문가의 멘탈 모델을 따르게 한다.

#### 구성 요소
- 밸류 오브젝트
- 애그리게이트
- 도메인 서비스

#### 밸류 오브젝트
색(color) 처럼 복합적인(composition) 값에 의해 식별되는 객체
```C#
class Color {
    int _red;
    int _green;
    int _blue;
}
```
- 같은 색의 두 인스턴스는 같은 값을 갖기 때문에 색을 구별하기 위한 명시적인 식별 필드가 필요 없다.

##### 유비쿼터스 언어
- 원시 데이터 타입(String, Integer 등)에 전적으로 의존해서 비즈니스 도메인의 개념을 표현하는 것은 원시 집착 코드 징후로 알려져 있다

```C#
class Person {
    private int     _id;
    private string  _landlinePhone;
    private string  _countryCode;
    ...

    public Person(...) {...}
}

static void main(string[] args) {

    var person = new Person(
        id: 1, 
        landlinePhone: "01234567", 
        countryCode: "BG", 
        ...)
}
```
문제점
- 유효성 검사 로직이 중복되기 쉬움
- 값이 사용되기 전에 유효성 검사 로직을 호출하게 하기 어려움

```C#
class Person {
    private PersonId    _id;
    private PhoneNumber _landline;
    private Countrycode _country;
    ...

    public Person(...) {...}
}

static void main(string[] args) {

    var person = new Person(
        id: new PersonId(1), 
        landline: PhoneNumber.Parse("01234567"),
        country: CountryCode.Parse("BG"),
        ...)
}
```
장점
- 명료성이 향상된다. 짧은 변수명을 사용하더라도 의도를 명확히 전달할 수 있다.
- 유효성 검사 로직이 밸류 오브젝트 자체에 있기 때문에 값을 할당하기 전에 유효성 검사를 할 필요가 없다.
- 비즈니스 로직이 한곳에서 구현되고 쉽게 테스트 할 수 있다.
- 코드에서 비즈니스 도메인의 개념을 표현하게 된다.

또 다른 예시
```C#
var phone = PhoneNumber.Parse("+359877123503");
var country = phone.Country;
var phoneType = phone.PhoneType;
var isValid = PhoneNumber.IsValid("+97212026680")
```
- 밸류 오브젝트에 다양한 로직을 담을 수 있다.

##### 구현
- 밸류 오브젝트는 불변의 객체로 구현된다.
    - 필드가 하나라도 바뀌면 다른 값이 생성된다.
- 밸류 오브젝트의 동일성은 id 필드나 참조 대신 값을 기반으로 한다.
    - 동일성 검사 함수를 오버라이드 해서 적절히 구현하는 것이 중요하다.
- 예시
    - 닷넷, 자바등의 문자열 타입은 밸류 오브젝트로 구현되어 있다.
    - 모든 오퍼레이션은 새로운 인스턴스를 만든다.
    - 공백 제거, 문자열 합치기, 교체, 자르기 등과 같이 메서드로 하나 이상의 문자열 값을 조작하여 새로운 인스턴스를 생성하는 풍부한 동작을 내포한다.

##### 밸류 오브젝트를 사용하는 경우
- 가능한 모든 경우에 사용하는게 좋다.
    - 코드의 표현력을 높여준다. 
    - 분산되기 쉬운 비즈니스 로직을 한데 묶어준다.
    - 코드를 더욱 안전하게 해준다.
- 예시
    - 돈
    - 원시 타입으로 돈을 표현하면 돈과 관련된 비즈니스 로직을 한곳에 모아두는 것이 제한적이다.
        - 반올림 오류와 기타 정확도 관련 문제와 같은 버그가 발생하는 경우가 잦다.

#### 엔티티
- 밸류 오브젝트의 정반대
- 엔티티와 다른 엔티티 인스턴스와 구별하기 위해 명시적인 식별 필드가 필요하다.

```C#
class Person {
    // PersonId는 밸류 오브젝트 Id는 식별 필드
    public readonly PersonId Id;
    public Name Name { get; set; }

    public Person(PersonId id, Name name) {
        this.Id = id;
        this.Name = name;
    }
}
```
- 식별필드는 각 엔티티의 인스턴스마다 고유해야 한다.
- 식별필드는 엔티티의 생애주기 내내 불변이어야 한다.
- 밸류 오브젝트는 엔티티의 속성을 설명한다.
- 엔티티는 모든 비즈니스 도메인의 필수 구성 요소다.
- 엔티티는 단독으로 구현되지 않고 애그리게이트 패턴의 컨텍스트에서만 엔티티를 구현한다.