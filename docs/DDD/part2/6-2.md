## 복잡한 비즈니스 로직 다루기

#### 애그리게이트
- 애그리게이트는 엔티티이다. (식별 필드 + 생애주기 동안 상태가 변한다.)
    - 하지만 단순한 엔티티가 아닌 그 이상이다.
    - 데이터의 일관성을 보호해야 한다.
        - 애그리게이트의 데이터는 변할 수 있기 때문에 데이터의 일관성을 유지하기 위해 해결해야 할 과제가 있다.

##### 일관성 강화
애그리게이트는 일관성을 강화하는 경계다.
- 애그리게이트의 로직은 모든 들어오는 변경 요청을 검사해서 그 변경이 애그리게이트의 비즈니스 규칙에 위배되지 않게 해야한다.

데이터의 일관성은 애그리게이트의 비즈니스 로직을 통해서만 애그리게이트의 상태를 변경하게 해야 강화된다.
- 애그리게이트 외부의 모든 프로세스와 객체는 애그리게이트의 상태를 읽을수만 있다.
    - 애그리게이트의 퍼블릭 인터페이스에 포함된 관련 메서드를 실행해야만 상태를 변경할 수 있다.
    - 노출된 상태 변경 메서드는 커맨드라고도 부른다.

커맨드의 두 가지 구현 방식
- 애그리게이트 객체에 평범한 퍼블릭 메서드 구현
```C#
public class Ticket {

    ...

    public void AddMessage(UserId from, string body) {
        var message = new Message(from, body);
        _messages.Append(message);
    }
}
```
- 커맨드의 실행에 필요한 모든 입력값을 포함하는 파라미터 객체로 표현
```C#
public class Ticket {

    ...

    public void Execute(AddMessage cmd) {
        var message = new Message(cmd.from, cmd.body);
        _messages.Append(message);
    }
}
```
애그리게이트의 퍼블릭 인터페이스의 역할
- 입력값의 유효성 검사
- 관련된 모든 비즈니스 규칙과 불변성을 강화하는 것을 담당
- 엄격한 경계는 애그리게이트와 관련된 모든 비즈니스 로직이 한곳(=애그리게이트 자체)에 구현되게 한다.
    - 애그리게이트에서 애플리케이션 계층의 조율 동작을 좀 더 간단하게 만들 수 있다.
        - 애그리게이트의 현재 상태를 적재해서 필요한 동작을 수행하고 수정된 상태를 저장한 후 오퍼레이션의 결과를 호출자에게 반환하는 것을 간단하게 한다.

애그리게이트는 상태의 일관성을 유지하는 것이 중요하다.
- 여러 프로세스가 동시에 동일한 애그리게이트를 갱신하려 할 때, 첫 번째 트랜잭션이 커밋한 변경을 나중의 트랜잭션이 덮어쓰지 않게 해야한다.
    - 애그리게이트를 저장하는 데이터베이스에서 동시성 관리를 지원해야 한다.
    - 가장 간단한 형태는 버전 필드를 사용하는 것이다.

##### 트랜잭션 경계
- 애그리게이트는 자신의 비즈니스 로직을 통해서만 수정될 수 있기 때문에 트랜잭션 경계의 역할을 한다.
- 모든 애그리게이트의 상태 변경은 원자적인 단일 오퍼레이션으로 트랜잭션 처리돼야 한다.
    - 모든 변경이 커밋되거나 원래 상태로 돌아가야함
- 다중 애그리게이트 트랜잭션을 지원하는 시스템 오퍼레이션은 없다고 가정한다.
    - 데이터베이스 트랜잭션 하나당 한 개의 애그리게이트로, 개별적으로만 커밋

여러 애그리게이트에서 변경을 커밋해야 한다면 이는 잘못된 트랜잭션 경계의 신호이고 잘못된 애그리게이트의 경계다.

##### 엔티티 계층
여러 객체의 변경을 원자적인 단일 트랜잭션으로 지원하기 위해 애그리게이트 패턴은 엔티티 계층 구조와 유사하게 모든 트랜잭션을 공유해서 일관성을 유지한다.
- 티켓 <-> 메시지 <-> 첨부

엔티티와 밸류 오브젝트들이 도메인의 비즈니스 로직 경계 내에 있으면 동일한 애그리게이트에 속한다.

애그리게이트는 동일한 트랜잭션 경계에 속한 비즈니스 엔티티와 밸류 오브젝트들을 한데로 묶는다.

애그리게이트 경계에 속한 여러 엔티티에 걸친 비즈니스 규칙의 예
```C#
public class Ticket {
    ...
    List<Message> _messages;
    ...

    public void Execute(EvaluateAutomaticActions cmd) {
        if (this.IsEscalated && this.RemainingTimePercentage < 0.5 && 
            GetUnreadMessagesCount(for: AssignedAgent) > 0) {

            _agent = AssignNewAgent();
        }
    }

    public int GetUnreadMessagesCount(UserId id) {
        return ...
    }
}
```
- 애그리게이트는 일관된 데이터에 대해 모든 조건을 엄격하게 검사하도록 확인한다.
- 애그리게이트 데이터의 모든 변경이 원자적인 단일 트랜잭션으로 수행되도록 보장하여 점검이 완료된 후 수정되지 못하게 한다.

##### 다른 애그리게이트 참조하기
- 애그리게이트의 비즈니스 로직에 따라 강력한 일관성이 필요한 정보만 애그리게이트에 포함돼야 한다.

```C#
public class Ticket {
    private UserId              _customer;
    private List<ProductId>     _products;
    private UserId              _assignedAgent;
    private List<Message>       _messages;
    ...
}
```
- 외부 애그리게이트를 참조할 때는 ID를 이용한다.
    - 애그리게이트 경계에 속하지 않음을 명확히 하고 각 애그리게이트가 자신의 트랜잭션 경계를 갖게 보장하기 위함이다.

엔티티가 애그리게이트에 속하는지 판단하는 방법
- 비즈니스 로직 내에 궁극적으로 일관된 데이터를 다루는 상황이 되면 시스템의 상태를 손상시킬 수 
있는지 여부를 판단한 후 비즈니스 로직이 애그리게이트에 있는지 여부를 조사

##### 애그리게이트 루트
애그리게이트가 엔티티의 계층 구조를 대표하기 때문에 그중 하나만 애그리게이트의 퍼블릭 인터페이스, 즉 애그리게이트 루트로 지정되어야 한다.
- 예) 티켓, 메시지, 첨부 중에 티켓이 애그리게이트 루트가 된다.

##### 도메인 이벤트
- 외부에서 애그리게이트와 커뮤니케이션할 수 있는 수단
    - 도메인 이벤트는 애그리게이트의 퍼블릭 인터페이스의 일부
- 비즈니스 도메인에서 일어나는 중요한 이벤트를 설명하는 메시지
    - 이미 발생한 것이기 때문에 과거형으로 명명한다.

도메인 이벤트의 목적
- 비즈니스 도메인에서 일어난 일을 설명하고 이벤트와 관련된 모든 필요한 데이터를 제공

도메인 이벤트의 이름이 비즈니스 도메인에서 일어난 일을 간결하고 정확하게 반영해야 한다.

애그리게이트는 자신의 도메인 이벤트를 발행한다
- 다른 프로세스, 애그리게이트, 외부 시스템이 도메인 이벤트를 구독할 수 있고, 도메인 이벤트에 반응하는 자신만의 로직을 실행할 수 있다.

##### 유비쿼터스 언어
애그리게이트의 이름, 데이터 멤버, 동작 그리고 도메인 이벤트에 사용된 모든 용어는 모두 바운디드 컨텍스트의 유비쿼터스 언어로 명명돼야 한다.

#### 도메인 서비스
애그리게이트에도 밸류 오브젝트에도 속하지 않거나 복수의 애그리게이트에 관련된 비즈니스 로직을 다룰 상황이 생긴다.
- 도메인 서비스로 로직을 구현하면 된다.

도메인 서비스는 비즈니스 로직을 구현한 **상태가 없는 객체(stateless object)**다.
- 대부분 어떤 계산이나 분석을 수행하기 위한 다양한 시스템 구성요소의 호출을 조율한다.

도메인 서비스는 여러 애그리게이트의 작업을 쉽게 조율
- 한 개의 데이터베이스 트랜잭션에서 한 개의 애그리게이트 인스턴스만 수정할 수 있는 한계를 극복해주는 것이 아니다.
- 도메인 서비스는 여러 애그리게이트의 데이터를 **읽는 것**이 필요한 계산 로직을 구현하는 것을 도와준다.

#### 복잡성 관리
- 애그리게이트와 밸류 오브젝트 패턴은 복잡한 것을 불변성으로 감싸서 복잡성을 낮추는 것이다.
- 밸류 오브젝트: 상태와 관련된 모든 비즈니스 로직은 자신의 경계 안에 있다.
- 애그리게이트: 자신의 메서드를 통해서만 수정된다.

### 결론
- 밸류 오브젝트
    - ID 필드가 필요 없다. 
    - 밸류 오브젝트는 불변이다.(필드가 변경되면 의미상 새로운 값을 생성)
- 애그리게이트
    - 트랜잭션 경계를 공유하는 엔티티의 계층
- 도메인 서비스
    - 애그리게이트 또는 밸류 오브젝트에 속하지 않는 비즈니스 로직을 담는 상태가 없는 객체다.