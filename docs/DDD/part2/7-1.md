## 시간 차원의 모델링

이벤트 소싱 도메인 모델 패턴
- 도메인 모델과 동일한 전술적 패턴(밸류 오브젝트, 애그리게이트, 도메인 이벤트)을 사용한다.
- 이벤트 소싱 패턴을 사용하여 애그리게이트 상태를 관리한다.
    - 애그리게이트의 상태를 유지하는 대신 모델은 각 변경사항을 설명하는 도메인 이벤트를 생성하고, 애그리게이트 데이터에 대한 원천 데이터로 사용한다.

### 이벤트 소싱
상태 기반 모델에서 테이블의 스키마와 테이블에 저장된 데이터를 분석하는 것만으로도 수집할 수 있는 정보가 상당히 많다.
- 하지만 테이블의 각 정보에 대한 상태에 도달한 이력에 대한 이야기는 누락되어 있음
- 누락된 정보를 채우는 방법 중 하나는 이벤트 소싱을 사용하는 것이다.

lead-id | first-name | last-name | status | phone-number| followup-on | created-on | updated-on |
--------|------------|-----------|--------|-------------|-------------|-----------|------------|
12 | Casey | Davis | CONVERTED | 555-8101 | - | 2020-05-20T09:52:55.95Z | 2020-05-20T09:52:55.95Z |

이벤트 소싱 패턴
- 데이터 모델에 시간 차원을 도입
- 애그리게이트의 수명주기의 모든 변경 사항을 문서화 하는 이벤트를 유지한다.

```json
{
    "lead-id" : 12,
    "event-id": 0,
    "event-type" : "lead-initialized",
    "first-name" : "Casey",
    "last-name" : "David",
    "phone-number" : "555-2951",
    "timestamp" : "2020-05-20T09:52:55.95Z"
},
...
{
    "lead-id" : 12,
    "event-id" : 6,
    "event-type" : "payment-confirmed",
    "status" : "converted",
    "timestamp" : "2020-05-27T12:38:44.12Z"
}
```
고객의 상태는 이러한 도메인 이벤트로부터 쉽게 원하는 시점의 데이터를 추출할 수 있다.
- 간단한 변환 로직을 각 이벤트에 순차적으로 적용하면 된다.

```C#
public class LeadSearchModelProjection {
    ...

    public void Apply(LeadInitialized @event) {
        ...
        Version = 0
    }

    public void Apply(ContactDetailsChanged @event) {
        ...
        Version += 1;
    }
    
    ...

    public void Apply(PaymentConfirmed @event) {
        ...
        Version += 1;
    }
}
```
- 애그리게이트의 이벤트를 반복해서 순서대로 적절히 재정의한 Apply 메서드에 넣으면 테이블에 모델링된 상태 표현이 정확하게 만들어진다.
- 관련 이벤트만 적용하여 수명주기 중에 원하는 지점의 엔티티 상태를 프로젝션할 수 있다.
    - 버전 5에서 엔티티의 상태가 필요한 경우 처음 5개 이벤트만 적용하면 된다.

#### 검색
- 연락처 정보가 변경되어도 이벤트 소싱을 사용하면 과거 정보를 쉽게 프로젝션할 수 있다.
- LeadInitialized와 ContactDetailsChanged 이벤트를 사용하여 각 리드의 개인 세부 정보를 채운다.
```
LeadId: 12
Firstnames: ['Casey']
LastNames: ['David', 'Davis']
PhoneNumbers: ['555-2951', '555-8101']
Version: 6
```

#### 분석
후속 전화가 예약된 개수를 얻는 예시
```C#
public class AnalysisModelProjection {
    ...
    
    public void Apply(LeadInitialized @event) {
        ...
    }

    ...
    // 상태, 팔로우업, 버전등을 변경하는 여러 이벤트들을 받는 Apply 메서들이 존재..
}
```

```
LeadId: 12
Followups: 1
Status: Converted
Version: 6
```
- 예제에서 검색 최적화와 분석 최적화 모델을 메모리에서 프로젝션한다.
- 실제로 필요한 기능을 구현하려면 프로젝션된 모델을 데이터베이스에 유지해야 한다.
    - CQRS(command-query responsibility segregation: 명령과 조회의 책임 분리)를 사용하면 가능