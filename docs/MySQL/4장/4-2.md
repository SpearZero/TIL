## InnoDB 스토리지 엔진 아키텍처
InnoDB
- MySQL 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금 제공
    - 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.

### 프라이머리 키에 의한 클러스터링
InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장된다.
- 프라이머리 키 값의 순서대로 디스크에 저장
- 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용
- 프라이머리키 키가 클러스터링 인덱스이기 때문에 프라이머리 키를 이용한 레인지 스캔은 상당히 빨리 처리될 수 있다.

MyISAM
- 클러스터링 키를 지원하지 않음
- 프라이머리 키와 세컨더리 인덱스는 구조적으로 아무 차이가 없다.
    - 프라이머리 키는 유니크 제약을 가진 세컨더리 인덱스
- MyISAM의 모든 인덱스는 물리적인 레코드의 주소 값(ROWID)를 가진다.

### 외래 키 지원
InnoDB 스토리지 엔진 레벨에서 지원하는 기능이다.
- MyISAM이나 MEMORY 테이블에서 사용할 수 없다.

InnoDB에서 외래키 사용시 주의점
- 부모 테이블과 자식 테이블에 모두 해당 칼럼에 인덱스 생성이 필요하다.
- 변경 시에 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많다.

foreign_key_checks 시스템 변수
- OFF로 설정하면 외래 키 관게에 대한 체크 작업을 일시적으로 멈출 수 있다.
    - 외래 키 관계의 부모 테이블에 대한 작업(ON DELETE CASCADE, ON UPDATE CASCADE)도 무시하게 된다.
- 외래 키 체크를 일시적으로 체크 해제 후 작업을 했다면, 부모 테이블과 자식 테이블의 데이터 일관성을 맞춘 후 외래 키 체크 기능을 활성화 해야 한다.

### MVCC(Multi Version Concurrency Control)
- 일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이다.
- 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는데 있다.
- InnoDB는 언두 로그(Undo log)를 이용해 이 기능을 구현한다.
- 멀티 버전
    - 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미.

격리 수준(Isolation level)이 READ_COMMITTED인 MySQL 서버에서 InnoDB 스토리지 엔진의 예시
```sql
INSERT INTO member(m_id, m_name, m_area) VALUES(12, '홍길동', '서울');
COMMIT;
UPDATE member SET m_area = '경기' WHERE m_id = 12;
```
- UPDATE 문이 실행되면 커밋 실행 여부와 관계 없이 InnoDB의 버퍼 풀은 '경기'로 업데이트 된다.
    - 디스크의 데이터 파일에는 체크포인트나 InnoDB의 Write 스레드에 의해 새로운 값으로 업데이트돼 있을 수도 있고 아닐 수도 있다.
    - InnoDB는 ACID를 보장하기 때문에 일반적으로는 InnoDB의 버퍼 풀과 데이터 파일은 동일한 상태라고 가정해도 무방하다.

COMMIT이나 ROLLBACK 되지 않은 상태에서 다른 사용자가 다음 같은 쿼리로 작업중인 레코드를 조회하는 상황
```sql
SELECT * FROM member WHERE m_id = 12;
```
- 격리 수준에 따라 조회되는 데이터가 다르다.
    - READ_UNCOMMITTED 
        - 버퍼 풀이 현재 가지고 있는 변경된 데이터를 읽어서 반환한다.
        - '경기'를 반환한다.
    - READ_COMMITED, REPEATABLE_READ, SERIALIZABLE>
        - 변경되기 이전의 내용을 보관하고 있는 언두 영역의 데이터 반환
        - '서울'을 반환한다.

UPDATE 후 COMMIT 명령을 실행하면 InnoDB는 더 이상의 변경 작업 없이 지금의 상태를 영구적인 데이터로 만들어 버린다.
- 롤백을 실행하면 InnoDB는 언두 영역에 있는 백업된 데이터를 InnoDB 버퍼 풀로 다시 복구하고, 언두 영역의 내용을 삭제해 버린다.
- 커밋이 된다고 언두 영역의 백업 데이터가 항상 바로 삭제되는 것은 아니다.
    - 언두 영역을 필요로 하는 트랜잭션이 더는 없을 때 비로소 삭제된다.

### 잠금 없는 일관된 읽기(Non-Locking Consistent Read)
InnoDB 스토리지 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행한다.
- 잠금을 걸지 않기 때문에 InnoDB에서 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고, 읽기 작업이 가능하다.
- 격리 수준이 READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ인 경우
    - INSERT와 연결되지 않은 순수한 읽기(SELECT) 작업은 다른 트랜잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행된다.
- InnoDB에서는 변경되기 전의 데이터를 읽기 위해 언두 로그를 사용한다.
- 트랜잭션이 시작됐다면 가능한 한 빨리 롤백이나 커밋을 통해 트랜잭션을 완료하는 것이 좋다.
    - 오랜 시간 활성 상태인 트랜잭션으로 인해 MySQL 서버가 느려지거나 문제가 발생하는 경우가 있다.
        - 일관된 읽기를 위해 언두 로그를 삭제하지 못하고 계속 유지해야 하기 때문에 발생하는 문제다.

### 자동 데드락 감지
InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프(Wait-for-List) 형태로 관리한다.
- InnoDB 스토리지 엔진의 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션을 찾아 그 중 하나를 종료한다.
    - 언두 로그 레코드를 더 적게 가진 트랜잭션이 일반적으로 롤백 대상이 된다.
- innodb_table_locks 시스템 변수를 활성화 하면 스토리지 엔진 내부의 레코드 잠금 뿐만 아니라 테이블 레벨의 잠금까지 감지할 수 있게 된다.
    - 테이블 잠금을 볼 수 없으면 데드락 감지가 불확실 할 수도 있음.(테이블 잠금은 MySQL 엔진에서 관리)

동시 처리 스레드가 매우 많아지거나 각 트랜잭션이 가진 잠금이 많아지면 데드락 감지 스레드가 느려진다.
- 데드락 감지 스레드가 느려지면 서비스에 악영향을 미치게 된다.
- innodb_deadlock_detect 시스템 변수를 OFF 하면 데드락 감지 스레드는 작동하지 않는다.
    - innodb_lock_wait_timeout(초 단위 설정) 시스템 변수를 활성화 하면 데드락 상황에서 일정 시간이 지나면 자동으로 요청이 실패하고 에러 메시지를 반환하게 한다.
- 데드락 감지 스레드가 부담스럽다면, 
    - innodb_deadlock_detect를 OFF 하고, innodb_lock_wait_timeout을 활성화 하는 방법이 있다.

### 자동화된 장애 복구
InnoDB 데이터파일은 기본적으로 MySQL 서버가 시작될 때 항상 자동 복구를 수행한다.
- 이 단계에서 자동으로 복구될 수 없는 손상이 있다면 자동 복구를 멈추고 MySQL 서버는 종료돼 버린다.

innodb_force_recovery
- MySQL 서버가 시작될 때 InnoDB 스토리지 엔진이 데이터 파일이나 로그 파일의 손상 여부 검사 과정을 선별적으로 진행할 수 있게 한다.
- 옵션에 설정 가능한 값은 1 ~ 6 까지의 값이 존재하고 값이 커질수록 그만큼 심각한 상황이어서 데이터 손실 가능성이 커지고 복구 가능성은 적어진다.

innodb_force_recovery 설정으로 복구를 진행해도 MySQL 서버가 시작되지 않으면 백업을 이용해 다시 구축하는 방법밖에 없다.
- 마지막 풀 백업 시점부터 장애 시점까지의 바이너리 로그가 있다면 InnoDB의 복구를 이용하는 것보다 풀 백업과 바인너리 로그로 복구하는 편이 데이터 손실이 더 적을 수 있다.