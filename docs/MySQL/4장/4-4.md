## InnoDB 스토리지 엔진 아키텍처

### Double Write Buffer
리두 로그는 리두 로그 공간의 낭비를 막기 위해 페이지의 변경된 내용만 기록
- 더티 페이지를 디스크 파일로 플러시할 때 일부만 기록되는 문제가 발생하면 그 페이지의 내용을 복구할 수 없을 수도 있다.
    - 페이지가 일부만 기록되는 현상을 파셜 페이지(Partial-page) 또는 톤 페이지(Torn-page)라고 한다.
    - 하드웨어의 오작동이나 시스템 비정상 종료 등으로 발생

Double-Write 기법
- 페이지가 일부만 기록되는 문제를 막기 위한 기법
- DoubleWrite 버퍼의 내용은 실제 데이터 파일의 쓰기가 중간에 실패할 때만 원래의 목적으로 사용된다.
    - A,B,C,D,E의 더티 페이지를 묶어서 한 번의 디스크 쓰기로 시스템 테이블스페이스의 DoubleWrite 버퍼에 기록
    - InnoDB 스토리지 엔진은 더티 페이지를 파일의 적당한 위치에 하나씩 랜덤으로 쓰기 실행
    - 만약 페이지의 일부만 기록되면서 운영체제가 비정상적으로 종료되었다고 가정
    - InnoDB 스토리지 엔진은 재시작 시 데이터 파일의 페이지 내용과 DoubleWrite 버퍼의 내용을 비교하여 다른 내용이 있으면, 버퍼의 내용을 데이터 파일의 페이지로 복사한다.
- innodb_doublewrite 시스템 변수로 DoubleWrite 기능의 사용 여부를 결정한다.

DoubleWrite 버퍼는 HDD 에서 순차 디스크 쓰기를 사용하기 때문에 별로 부담이 되지 않지만, SSD 처럼 랜덤 IO나 순차 IO 비용이 비슷한 저장 시스템에서는 상당히 부담스럽다.
- 데이터 무결성이 중요한 경우 DoubleWrite의 활성화를 고려하는 것이 좋다.

### 언두 로그
InnoDB 스토리지 엔진은 트랜잭션과 격리수준을 보장하기 위해 DML(INSERT, UPDATE, DELETE)로 변경되기 이전 버전의 데이터를 별도로 백업한다.
- 백업된 데이터를 언두 로그(Undo Log)라고 한다.

언두 로그의 사용처
- 트랜잭션 보장
    - 트랜잭션 롤백시 변경된 데이터를 변경전 데이터로 복구하는데 사용한다.
- 격리 수준 보장
    - 트랜잭션 격리 수준에 맞게 변경 중인 레코드를 읽지 않고 언두 로그에 백업해둔 데이터를 읽어서 반환하는 경우가 있다.

#### 언두 로그 레코드 모니터링
MySQL 5.5 이전 버전의 MySQL 서버에서는 한 번 증가한 언두 로그 공간은 다시 줄어들지 않았다.
- 대량의 데이터 삭제시 MySQL 서버는 레코드를 한 건 삭제하고 이를 언두 로그에 삭제되기 전 값을 저장

트랜잭션이 오랜 시간 동안 실행될 떄도 언두 로그 양은 급격히 증가할 수 있다.
- A트랜잭션이 오랫동안 실행되고, B,C 트랜잭션이 DML을 실행하면 B,C 작업의 변경분이 언두 로그에 저장된다.(트랜잭션 완료 여부와 상관없이)
- 빈번하게 변견된 레코드를 조회하는 쿼리가 실행되면 InnoDB는 언두 로그의 이력을 필요한 만큼 스캔해야만 필요한 레코드를 찾을 수 있기 때문에 쿼리의 성능이 전반적으로 떨어진다.

MySQL 8.0에서는 언두 로그 공간의 문제점이 해결 되었다.
- 언두 로그를 돌아가면서 순차적으로 사용해 디스크 공간을 줄이는 것이 가능하다.
- MySQL 서버가 필요한 시점에 사용 공간을 자동으로 줄여주기도 한다.

#### 언두 테이블스페이스 관리
- MySQL 5.6 이전
    - 언두 로그가 모두 시스템 테이블 스페이스(ibdata.idb)에 저장됨
    - 시스템 테이블 스페이스의 언두 로그는 MySQL 서버가 초기화 될 때 생성되기 때문에 확장에 한계가 있음
- MySQL 5.6 버전
    - innodb_undo_tablespaces 시스템 변수 도입
        - 2보다 큰 값 설정시 별도의 언두 로그 파일 사용
        - 0으로 설정하면 언두로그가 시스템 테이블스페이스에 저장
- MySQL 8.0(8.0.14 버전 부터)
    - innodb_undo_tablespaces 시스템 변수는 deprecated 됨
    - 언두 로그는 항상 시스템 테이블스페이스 외부의 별도 로그 파일에 기록

언두 테이블스페이스의 구성
- 하나의 언두 테이블스페이스는 1 ~ 128개의 롤백 세그먼트를 가짐
- 롤백 세그먼트는 1개 이상의 언두 슬롯(Undo Slot)을 가짐
- 하나의 롤백 세그먼트는 InnoDB의 페이지 크기를 16바이트로 나눈 값의 개수만큼 언두 슬롯을 가진다.
```
최대 동시 트랜잭션 수 = (InnoDB 페이지 크기) / 16 * (롤백 세그먼트 개수) * (언두 테이블스페이스 개수)
```

언두 로그 슬롯이 부족한 경우에는 트랜잭션을 시작할 수 없는 심각한 문제가 발생한다.

MySQL 8.0 이후 버전부터는 언두 테이블 스페이스를 동적으로 추가하고 삭제할 수 있다.

언두 테이블스페이스 공간을 필요한 만큼만 남기고 불필요하거나 과도하게 할당된 공간을 운영체제에 반납할 수 있다.(Undo tablespace truncate) 
- MySQL 8.0부터 지원되며 자동과 수동 두 가지 방법이 있다.

### 체인지 버퍼
레코드가 INSERT 되거나 UPDATE될 때는 데이터 파일 변경 작업 뿐 아니라 인덱스를 업데이트 하는 작업도 필요하다.
- 인덱스 업데이트는 랜덤하게 디스크를 읽는 작업이 필요한데, 인덱스가 많다면 이 작업믄 많은 자원을 소모한다.
    - InnoDB는 변경해야 할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트 수행
    - 디스크로부터 읽어와서 업데이트 해야 한다면 이를 즉시 실행하지 않고 임시 공간에 저장해두고 바로 사용자에게 결과 반환하는 형태로 성능을 향상
        - 이 때 사용하는 임시 메모리 공간을 체인지 버퍼(Chnage Buffer)라고 한다.

유니크 인덱스는 체인지 버퍼를 사용할 수 없다.
- 사용자에게 결과를 전달하기 전에 반드시 중복 체크를 해야 한다.
- 중복 여부를 디스크 상의 인덱스를 보고 직접 확인 해야 하는데, 체인지 버퍼가 디스크 인덱스 페이지를 읽지 않음

체인지 버퍼 머지 스레드(Merge thread)
- 체인지 버퍼에 임시로 저장된 인덱스 레코드 조각을 백그라운드 작업으로 병합시켜준다.
- MySQL 5.5 이전 버전 까지는 INSERT 작업에 대해서만 버퍼링이 가능(인서트 버퍼라고도 했음)
- MySQL 8.0 에서는 INSERT, DELETE, UPDATE 작업에 대해서도 버퍼링이 될 수 있게 개선

innodb_change_buffering
- MySQL 5.5부터 도입되어 작업의 종류별로 체인지 버퍼를 활성화 할 수 있다.

### 리두 로그 및 로그 버퍼
리두 로그는 ACID에서 D(Durable, 영속성)와 밀접한 연관이 있다.
- MySQL 서버가 비정상적으로 종료됐을 때 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안전 장치다.

MySQL 서버는 데이터의 변경 내용을 로그로 먼저 기록한다.
- 리두 로그를 WAL(Write Ahead Log) 라고도한다.
- 거의 모든 DBMS는 쓰기보다 읽기 성능을 고려한 자료 구조를 가지고 있음
    - 데이터 파일 쓰기는 디스크의 랜덤 액세스가 필요하다.
        - 변경된 데이터를 데이터 파일에 기록하려면 상대적으로 큰 비용이 발생한다.
        - 성능 저하를 막기 위해 쓰기 비용이 낮은 리두 로그를 가지고 있다.

리두 로그의 내용을 이용해 데이터 파일을 서버가 종료되기 직전의 상태로 복구할 수 있다.

데이터베이스는 ACID 뿐만 아니라 성능도 중요하기 때문에 데이터 파일 뿐만 아니라 리두 로그를 버퍼링할 수 있는 InnoDB 버퍼 풀, 로그 버퍼와 같은 자료 구조도 가지고 있다.

MySQL 서버가 비정상 종료시 데이터 파일이 가질 수 있는 일관되지 않은 데이터
- 커밋이됐지만 데이터 파일에 기록되지 않은 데이터
    - 리두 로그에 저장된 데이터를 데이터 파일에 다시 복사하면 된다.
- 롤백됐지만 데이터 파일에 이미 기록된 데이터
    - 언두 로그의 내용을 가져와 데이터 파일에 복사하면 된다.

리두 로그는 트랜잭션이 커밋되면 즉시 디스크로 기록되도록 시스템 변수를 설정하는 것을 권장한다.
- 리두 로그를 이용하여 장애 직전 시점까지 복구가 가능해진다.

트랜잭션이 커밋될 때마다 리두 로그를 디스크에 기록하는 작업은 부하가 크다.
- innodb_flush_log_at_trx_commit 시스템 변수를 사용하여 디스크 동기화 주기를 결정할 수 있다.
    - 1은 매번 트랜잭션이 커밋될 때마다 디스크에 기록 및 동기화 수행
    - 0,2는 디스크 동기화 작업이 1초마다 수행

#### 리두 로그 아카이빙
MySQL 8.0 버전부터 InnoDB 스토리지 엔진의 리두 로그를 아카이빙할 수 있는 기능이 추가됐다.
- MySQL 8.0의 리두 로그 아카이빙 기능은 데이터 변경이 많아서 리두 로그가 덮어쓰인다고 하더라도 백업이 실패하지 않게 해준다.(LSN 순환이 빠르면 덮이 씌워지므로)

#### 리두 로그 활성화 및 비활성화
MySQL 8.0부터는 리두 로그를 활성화/비활성화 할 수 있게 해준다.
- 데이터를 복구하거나 대용량 데이터를 한번에 적재하는 경우 리두 로그를 비활성화 해서 데이터의 적재 시간을 단축시킬 수 있다.
- 리두 로그를 비활성화 후 데이터 적재가 완료되었다면, 리두 로그를 다시 활성화 해야 한다.
    - 리두 로그 비활성화 상태에서 MySQL 서버가 비정상적으로 종료되면, 서버의 마지막 체크 포인트 이후 시점의 데이터는 복구할 수 없다.
    - 더 심각한 문제는 MySQL 서버의 데이터가 마지막 체크포인트 시점의 일관된 상태가 아닐 수 있다.
        - 일부 데이터는 적재되고, 일부 데이터는 적재되지 않음

MySQL 서버가 비정상적으로 종료되어 데이터 일부가 손실돼도 괜찮다면
- 리두 로그를 비활성화 하는 것보다, innodb_flust_log-at_trx_commit 시스템 변수를 0 또는 2로 설정해서 사용할 것을 권장한다.