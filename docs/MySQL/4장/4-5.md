## InnoDB 스토리지 엔진 아키텍처

### 어댑티브 해시 인덱스
- 사용자가 수동으로 생성하는 인덱스가 아니라 InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스
- innodb_adaptive_hash_index 시스템 변수를 이용해 활성/비활성화 할 수 있다.

B-Tree 노드는 루트, 브랜치, 리프 노드를 찾아가야 원하는 레코드를 읽을 수 있다.
- 이런 작업이 몇 개 실행되면 성능 저하가 일어나지 않지만, 수 천개의 스레드로 실행하면 쿼리의 성능이 저하 된다.

어댑티브 해시 인덱스는 B-Tree 검색 시간을 줄여주기 위해 도입된 기능
1. InnoDB 스토리지 엔진은 자주 읽히는 데이터 페이지의 키 값을 이용해 해시 인덱스를 만든다.
2. 필요할 때마다 어댑티브 해시 인덱스를 검색해서 레코드가 저장된 데이터 페이지를 즉시 찾아갈 수 있다.

해시 인덱스
- '인덱스 키 값'과 해당 인덱스 키 값이 저장된 '데이터 페이지 주소'의 쌍으로 관리
- 인덱스 키 값은 'B-Tree 인덱스의 고유 번호(Id)와 B-Tree 인덱스의 실제 키 값'으로 생성
- 인덱스의 고유번호가 포함되는 이유
    - 어댑티브 해시 인덱스는 하나만 존재하기 때문
    - 모든 B-Tree 인덱스에 대한 어댑티브 해시 인덱스가 하나의 해시 인덱스에 저장되며, 특정 키 값이 어느 인덱스에 속한 것인지도 구분 해야 한다.
- 데이터 페이지 주소는 실제 키 값이 저장된 데이터 페이지의 메모리 주소를 가진다.
    - InnoDB 버퍼 풀에 로딩된 페이지 주소를 의미한다.

어댑티브 해시 인덱스는 버퍼 풀에 올려진 데이터 페이지에 대해서만 관리되고, 버퍼 풀에서 해당 데이터 페이지가 없어지면 어댑티브 해시 인딕스에서도 해당 페이지의 정보가 사라진다.

MySQL 8.0부터 내부 잠금(세마포어) 경합을 줄이기 위해 어댑티브 해시 인덱스의 파티션 기능을 제공한다.
- 이전 버전 까지는 어댑티브 해시 인덱스가 하나의 메모리 객체인 이유로 경합(Contention)이 상당히 심했다.
- innodb_adaptive_hash_index_parts 시스템 변수를 이용해 파티션 개수를 변경할 수 있다.(기본값은 8)

어댑티브 해시 인덱스가 도움이 되지 않는 경우
- 디스크 읽기가 많은 경우
- 특정 패턴의 쿼리가 많은 경우(조인, LIKE 검색)
- 매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우

어댑티브 해시 인덱스가 도움이 되는 경우
- 디스크의 데이터가 InnoDB 버퍼 풀 크기와 비슷한 경우(디스크 읽기가 많지 않은 경우)
- 동등 조건 검색(동등 비교, IN 연산)이 많은 경우
- 쿼리가 데이터 중에서 일부 데이터에만 집중되는 경우

어댑티브 해시 인덱스 단점
- 상당히 큰 메모리 공간을 사용할 수 있다.
- 데이터 페이지의 인덱스 키가 해시 인덱스로 만들어져야 하며, 불필요한 경우 제거 되어야 한다.
- 어댑티브 해시 인덱스가 활성화 되어 있다면 InnoDB 스토리지 엔진은 그 키 값이 해시 인덱스에 있든 없든 검색해봐야 한다.
- 특정 테이블을 삭제하거나 변경하면, 이 테이블이 가진 모든 데이터 페이지의 내용을 어댑티브 해시 인덱스에서 제거해야 한다.
    - 많은 CPU 자원을 사용하고, 데이터베이스 서버의 처리 성능이 느려진다.

### InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교
MySQL 8.0으로 업그레이드 되면서 변한 점
- MySQL 서버의 모든 시스템 테이블이 InnoDB 스토리지 엔진으로 교체
    - 시스템 테이블 : 사용자 인증 관련된 정보와 복제 관련된 정보가 저장된 mysql DB의 테이블
- 공간 좌표 검색이나 전문 검색 기능이 모두 InnoDB 스토리지 엔진을 지원하도록 개선
- MySQL 8.0 버전부터는 MySQL 서버의 모든 기능을 InnoDB 스토리지 엔진만으로 구현할 수 있음

InnoDB vs MEMORY
- 하나의 데이터를 읽고 쓴다면 MEMORY가 InnoDB보다 빠를 수 있음
- MySQL은 일반적으로 온라인 트랜잭션 처리를 위한 목적으로 사용한다.
    - 수십 또는 수 백개의 클라이언트에서 쿼리 요청이 실행되는 등의 동시 처리 성능이 중요하다. MEMORY 스토리지 엔진은 테이블 수준의 잠금으로 제대로 된 성능을 내기 힘들다.