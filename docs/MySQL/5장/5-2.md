## MySQL 엔진의 잠금
MySQL에서 사용되는 잠금
- 스토리지 엔진 레벨
- MySQL 엔진 레벨
    - 스토리지 엔진을 제외한 나머지 부분

MySQL 엔진 레벨의 짐금은 모든 스토리지 엔진에 영향을 미치지만, 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지 않는다.

### 글로벌 락
- FLUSH TABLES WITH READ LOCK 명령으로 획득
- MySQL에서 제공하는 잠금 중 제일 범위가 크다.
    - 한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT를 제외한 대부분의 DDL, DML 문장을 실행하는 경우 글로벌 락이 해제될 때까지 해당 문장이 대기 상태로 남는다.
- MySQL 서버 전체에 영향을 미친다.
    - 작업 대상이나 데이터베이스가 다르더라도 동일하게 영향을 미친다.

MyISAM이나 MEMORY 테이블에 대해 mysqldump로 일관된 백업을 받아야 할 때는 글로벌 락을 사용

InnoDB는 트랜잭션을 지원하기 때문에 일관된 데이터 상태를 위해 모든 데이터의 변경 작업을 멈출 필요는 없다.

MySQL 8.0부터는 InnoDB가 기본 스토리지 엔진으로 채택되면서 조금 더 가벼운 글로벌 락의 필요성이 생김
- 백업 락 도입
- 백업 락 획득시 모든 세션에서 사용할 수 없는 기능
    - 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
    - REPAIR TABLE과 OPTIMIZE TABLE 명령
    - 사용자 관리 및 비밀번호 변경
- 백업 락은 일반적인 테이블의 데이터 변경은 허용한다.
- 주로 백업은 소스가 아닌 레플리카 서버에서 실행된다.

백업 도중 DDL 명령이 실행되어 백업이 실패하면 다시 백업을 해야한다.
- 이러한 문제를 해결하기 위해 백업 락 도입
- 백업 락은 정상적으로 복제는 실행되지만 백업의 실패를 막기 위해 DDL 명령이 실행되면 복제를 일시 중지하는 역할을 한다.

### 테이블 락
- 개별 테이블 단위로 설정되는 잠금
- 명시적 또는 묵시적으로 획득 가능
- 명시적으로 LOCK TABLES table_name [READ | WRITE] 명령으로 가능
    - UNLOCK TABLES로 반납
- 특별한 상황이 아니면 애플리케이션에서 사용할 필요가 거의 없음
    - 글로벌 락과 마찬가지로 온라인 작업에 상당한 영향을 미친다.
- 테이블 락은 MyISAM, InnoDB 테이블에도 설정 가능
- MyISAM, MEMORY 에서는 테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다.
    - 데이터가 변경되는 테이블에 잠금을 설정하고 데이터를 변경한 후, 잠금을 해제
    - 자동으로 획득 되었다가 해제된다.
- InnoDB 테이블은 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공한다.
    - 단순 데이터 변경 쿼리로 인한 묵시적인 테이블 락이 설정 되지 않음
    - 정확히는 테이블 락이 설정되지만 대부분의 데이터 변경(DML) 쿼리에서는 무시되고, 스키마를 변경하는 쿼리(DDL)의 경우에만 영향을 미친다.

### 네임드 락
- GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있다.
- 테이블이나 레코드 또는 AUTO_INCREMENT와 같은 데이터베이스 객체가 아니라 문자열에 대해  획득하고 반납(해제)하는 잠금이다.
- 사용 예
    - 여러 클라이언트가 상호 동기화를 처리해야 할 때 네임드락 이용(5대의 웹 서버와 한 대의 데이터베이스)
    - 많은 레코드에 대해서 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용
        - 배치 프로그램처럼 한꺼번에 많은 레코드를 변경하는 쿼리는 자주 데드락의 원인이 됨
        - 실행 시간을 분산하거나 프로그램의 코드를 수정하면 데드락을 최소화 할 수 있지만 간단하지 않으며 완전한 해결책이 아님
        - 배치 프로그램에서 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 네임드 락을 걸고 쿼리를 실행하면 아주 간단히 해결할 수 있다.

### 메타데이터 락
데이터베이스 객체(테이블, 뷰 등)의 이름이나 구조를 변경하는 경우에 획득하는 잠금
- 명시적으로 획득하거나 해제할 수 없다. "RENAME TABLE tab_a TO tab_b" 등과 같이 테이블의 이름을 변경하는 경우 자동으로 획득하는 잠금
- RENAME TABLE 명령의 경우 원본 이름과 변경될 이름 두 개 모두 한꺼번에 잠금을 설정한다.

```sql
-- // "Table not found 'rank" 발생하지 않음
RENAME TABLE rank TO rank_backup, rank_new TO rank;

-- // "Table not found 'rank" 발생
RENAME TABLE rank TO rank_backup;
RENAME TABLE rank_new TO rank;
```

메타데이터 잠금과 InnoDB 트랜잭션을 동시에 사용하는 경우
- INSERT만 실행되는 로그 테이블의 구조를 변경해야 하는 경우
    - Online DDL을 사용해서 변경할 수 있지만 시간이 오래 걸리는 경우 언두 로그의 증가와 Online DDL이 실행되는 동안 누적된 Online DDL 버퍼의 크기 등 고민해야 할 문제가 많다.
    - 단일 스레드로 작동하기 때문에 상당히 많은 시간이 소모된다.
- 이 경우 새로운 구조의 테이블을 생성하고 먼저 최근(1시간 직전 또는 하루 전)의 데이터까지는 PK 값을 범위별로 나눠서 여러개의 스레드에 빠르게 복사한다.
- 그 후 나머지 데이터는 트랜잭션과 테이블 잠금, RENAME TABLE 명령으로 응용 프로그램의 중단없이 실행할 수 있다.