## InnoDB 스토리지 엔진 잠금
InnoDB는 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고 있다.
- 레코드 기반의 잠금 방식 덕분에 MyISAM보다는 훨씬 뛰어난 동시성 처리를 제공할 수 있다.

이원화된 잠금 처리 탓에 InnoDB 스토리지 엔진에서 사용되는 잠금에 대한 정보는 MySQL 명령을 이용해 접근하기 까다롭다.
- 예전 버전의 MySQL 서버에서는 lock_monitor와 SHOW ENGINE INNODB STATUS 명령으로만 InnoDB의 잠금 정보를 볼 수 있었다.
- 최근 버전에서는 InnoDB의 트랜잭션과 잠금, 잠금 대기 중인 트랜잭션의 목록을 조회할 수 있는 방법이 도입되었다.
    - information_schema에 존재하는 INNODB_TRX, INNODB_LOCKS, INNODB_LOCK_WAITS 테이블을 조인해서 트랜잭션과 잠금에 대한 정보를 얻을 수 있다.
    - Performance Schema를 이용해 InnoDB 스토리지 엔진의 내부 잠금(세마포어)에 대한 모니터링도 할 수 있다.

### InnoDB 스토리지 엔진의 잠금
- InnoDB 스토리지 엔진은 레코드 기반의 잠금 기능 제공
- 잠금 정보가 상당히 작은 공간으로 관리 되기 때문에 락 에스컬리에션은 없음
    - 레코드 락 -> 페이지 락 or 테이블 락으로 레벨업 되는 경우는 없다.
- 레코드 락 뿐만 아니라 레코드와 레코드 사이의 간격을 잠그는 갭(GAP)락 존재

#### 레코드 락
- 레코드 자체만을 잠그는 것을 레코드 락(Record lock, Record only lock) 이라고 한다.
- InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다.
    - 인덱스가 하나도 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다.

보조 인덱스를 이용한 변경 작업은 넥스트 키 락(Next key lock) 또는 갭 락(Gap lock)을 사용한다.

프라이머리 키 또는 유니크 인덱스에 의한 변경 작업에서는 갭(Gap, 간격)에 대해서는 잠그지 않고 레코드 자체에 대해서만 락을 건다.

#### 갭 락
- 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미한다.
- 레코드와 레코드 사이에 새로운 레코드가 INSERT 되는 것을 제어한다.
- 갭 락은 그 자체보다는 넥스트 키 락의 일부로 자주 사용된다.

#### 넥스트 키 
- 레코드 락과 갭 락을 합쳐 놓은 형태의 잠금
- innodb_locks_unsafe_for_binlog 시스템 변수가 비활성화(0)되면 변경을 위해 검색하는 레코드에는 넥스트 키 락 방식으로 잠금이 걸린다.
- InnoDB의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주 목적이다.
- 의외로 넥스트 키 락과 갭락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생
    - 가능하다면 바이너리 로그 포맷을 ROW 형태로 바꿔서 넥스트 키 락이나 갭 락을 줄이는 것이 좋다.
    - MySQL 8.0에서는 ROW 포맷의 바이너리 로그가 기본 설정이다.(STATEMENT 포맷의 바이너리 로그가 가지는 단점을 많이 해결해준다.)

#### 자동 증가 락
- 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 가지기 위해 AUTO_INCREMENT 락(Auto increment lock)을 사용한다.
- INSERT와 REPLACE 쿼리 문장과 같이 새로운 레코드를 저장하는 쿼리에서만 필요하다.
    - UPDATE, DELETE 등의 쿼리에서는 걸리지 않는다.
- AUTO_INCREMENT 락은 트랜잭션과 관계 없이 INSERT나 REPLACE 문장에서 AUTO_INCREMENT 값을 가져오는 순간만 락이 걸렸다가 즉시 해제된다.
- AUTO_INCREMENT 락은 테이블에 단 하나만 존재한다.
    - 두 개의 INSERT 쿼리가 동시에 실행되는 경우 하나의 쿼리가 AUTO_INCREMENT 락을 걸면 나머지 쿼리는 AUTO_INCREMENT 락을 기다려야 한다.

명시적으로 AUTO_INCREMENT 락을 획득하거나 해제하는 방법은 없다.

AUTO_INCREMENT 락은 아주 짧은 시간 동안 걸렸다가 해제되는 잠금이라서 대부분의 경우 문제가 되지 않는다.

MySQL 5.1 이상부터는 innodb_autoinc_lock_mode라는 시스템 변수를 이용해 자동 증가 락의 작동 방식을 변경할 수 있다.
- innodb_autoinc_lock_mode=0
    - MySQL 5.0과 동일한 잠금 방식, 모든 INSERT 문장은 자동 증가 락 사용
- innodb_autoinc_loc_mode=1
    - INSERT 되는 레코드 건수를 정확히 예측할 수 있으면 자동 증가 락 대신 훨씬 가볍고 빠른 래치를 사용한다.
    - 아주 짧은 시간만 잠금을 걸고 필요한 자동 증가 값을 가져오면 즉시 잠금이 해제된다.
    - 쿼리를 실행하기 전에 건수를 예측할 수 없을 경우(INSERT ... SELECT) MySQL 5.0과 같이 자동 증가 락 사용
        - 이 경우 INSERT 문장이 완료되기 전까지 자동 증가 락이 해제되지 않기 때문에, 다른 커넥션에서는 INSERT를 실행하지 못하고 대기
        - 대량 INSERT일 경우 여러개의 자동 증가 값을 한 번에 할당 받아 INSERT 되는 레코드에 사용한다. 레코드는 순차적인 키 값을 가지지만, 자동 증가 값이 남는 경우 폐기된다.
            - 대량 INSERT 후 다음 INSERT 되는 레코드의 자동 증가값이 연속되지 않고 누락된 값이 발생할 수 있음
- innodb_autoinc_lock_mode=2
    - 절대 자동 증가 락을 걸지않고 경량화된 래치(뮤텍스) 사용
    - 하나의 INSERT 문장으로 INSERT 되는 레코드라고 하더라도 연속된 자동 증가값을 보장하지 않는다.
    - INSERT ... SELECT와 같은 대량 INSERT 문장이 실행되는 중에도 다른 커넥션이 INSERT를 수행할 수 있다. (동시 처리 성능이 높아짐)
        - 유니크한 값을 생성한다는 것만 보장
    - STATEMENT 포맷의 바이너리 로그를 사용하는 복제에서는 소스 서버와 레플리카 서버의 자동 증가 값이 달라질 수 있으므로 주의 해야 한다.

버전별 innodb_auto_lock_mode 기본값
- MySQL 5.7에서는 1, MySQL 8.0 버전부터는 2
    - 바이너리 로그 포맷의 기본값이 STATEMENT -> ROW가 되었기 때문이다.
- MySQL 8.0에서 ROW 포맷이 아닌 STATEMENT 포맷을 사용할 경우, 설정값을 1로 변경해서 사용할 것을 권장

### 인덱스와 잠금
InnoDB는 레코드가 아닌 인덱스를 잠그는 방식으로 처리된다.

```sql
UPDATE employees SET hire_date=NOW() WHERE first_name='Georgi' AND last_name='Klassen';
```

first_name에 인덱스가 걸려 있다면, first_name의 Georgi인 레코드들이 모두 잠긴다.

UPDATE 문장을 위해 적절히 인덱스가 준비돼 있지 않다면 각 클라이언트 간의 동시성이 상당히 떨어져서 한 세션에서 UPDATE 작업을 하는 중에 다른 클라이언트는 그 테이블을 업데이트하지 못하고 기다리는 상황이 발생할 것이다.

테이블에 인덱스가 없다면 풀 스캔 하면서 UPDATE를 수행하는데 이 과정에서 테이블의 모든 레코드가 잠기게 될 것이다.

### 레코드 수준의 잠금 확인 및 해제
- InnoDB 스토리지 엔진을 사용하는 테이블의 레코드 수준 잠금은 테이블 수준의 잠금보다는 조금 더 복잡하다.
    - 테이블 잠금은 잠금의 대상이 테이블 그 자체이다. (원인이 쉽게 발견됨)
    - 레코드 잠금은 레코드 각각에 잠금이 걸리므로 그 레코드가 자주 사용되지 않으면 오랜 기간 잠겨진 상태로 남아 있어도 잘 발견되지 않는다.

MySQL 5.1 부터는 information_schema라는 DB로 잠금에 대한 정보를 조회할 수 있다.
- INNODB_TRX, INNODB_LOCKS, INNODB_LOCK_WAITS라는 테이블을 통해 확인 가능

MySQL 8.0 부터는 information_schema의 정보들이 조금씩 Deprecated 되고 있음
- 대신, performance_schema의 data_locks와 data_locks_waits 테이블로 대체되고 있다.