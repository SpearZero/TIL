## 디스크 읽기 방식
데이터베이스의 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건일 때가 상당히 많다.

### 하드 디스크 드라이브(HDD)와 솔릳 스테이트 드라이브(SSD)
SSD
- 기존 하드 디스크 드라이브에서 데이터 저장용 플래터(원판)를 제거하고 그 대신 플래시 메모리를 장착

디스크의 헤더를 움직이지 않고 한 번에 많은 데이터를 읽는 순차 I/O에서는 SSD가 하드 디스크 드라이브보다 조금 빠르거나 거의 비슷한 성능을 보인다.
- 단, SSD는 하드 디스크보다 랜덤 I/O가 훨씬 빠르다.
- 데이터베이스 서버에서 순차 I/O 작업보다 랜덤 I/O 비중이 크다.(작은 데이터를 읽고 쓰는 작업이 대부분)

### 랜덤 I/O와 순차 I/O
- 순차 I/O는 3개의 페이지를 디스크에 기록하기 위해 시스템 콜을 1번 요청
- 랜덤 I/O는 3개의 페이지를 디스크에 기록하기 위해 시스템 콜을 3번 요청

디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 의해 결정된다고 볼 수 있다.

일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적이다.

## 인덱스란?
책의 비유
- 찾아 보기 : 인덱스
    - 찾아보기를 통해 알아낼 수 있는 페이지 번호는 데이터 파일에 저장된 레코드의 주소에 비유
- 책의 내용 : 데이터 파일

검색 속도 향상을 위해 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍(Key Value pair)으로 삼아 인덱스로 만들어 둔다.

DBMS의 인덱스는 칼럼의 값을 주어진 순서로 미리 정렬해서 보관한다.

- 인덱스
    - 항상 정렬된 상태로 유지
- 데이터 파일
    - 저장된 순서대로 별도의 정렬 없이 그대로 저장

인덱스는 저장할 때 항상 정렬해야 하므로 저장하는 과정이 복잡하고 느리지만, 이미 정렬돼 있어서 아주 빨리 원하는 값을 찾아올 수 있다.
- INSERT, UPDATE, DELETE 성능을 희생하고, SELECT의 속도를 높인다.

인덱스의 역할별 구분
- 프라이머리 키
    - 레코드를 대표하는 값으로 만들어진 인덱스
    - 레코드를 식별하기 때문에 식별자라고 한다.
        - 중복과 NULL을 허용하지 않음
- 세컨더리 인덱스
    - 프라이머리 키를 제외한 모든 인덱스
    - 유니크 인덱스는 대체 키라고도 한다.
        - 프라이머리 키와 성격이 비슷하고 프라이머리 키를 대체할 수 있음

데이터 저장 방식별로 구분
- B-Tree 알고리즘
    - 가장 일반적으로 사용되는 인덱스 알고리즘
    - 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱한다.
    - 위치 기반 검색을 지원하기 위한 R-Tree도 B-Tree 기반이다.
- Hash 인덱스 알고리즘
    - 칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘
        - 빠른 검색을 지원
    - 값을 변형해서 인덱싱하므로 값의 일부(ex, Prefix)만 검색하거나 범위를 검색할 때는 사용할 수 없다.
    - 주로 메모리 기반의 데이터베이스에서 많이 사용한다.

데이터 중복 허용 여부에 의한 분류
- 유니크(Unique) vs 유니크 하지 않음(Non-Unique)
- 같은 값이 1개만 존재하는지 vs 1개 이상 존재할 수 있는지를 의미한다.
    - 옵티마이저에게 유니크인지 아닌지는 상당히 중요한 문제가 된다.
        - 유니크 여부에 따라 MySQL의 처리 방식의 변화나 차이점이 상당히 많다.
        