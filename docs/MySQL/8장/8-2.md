## B-Tree 인덱스
B-Tree
- Balanced Tree
- 칼럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태를 유지한다.
    - 값의 앞부분만 잘라서 관리
- 전문 검색과 같은 특수한 요건이 아니면, 대부분 인덱스는 거의 B-Tree를 사용

### 구조 및 특성
- 루트 노트(Root node)
    - 최상위에 하나만 존재
- 브랜치 노드(Branch node)
    - 루트 노드와 리프 노드가 아닌 중간의 노드
- 리프 노드(Leaf node)
    - 트리의 가장 하위에 존재
    - 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값이 존재

인덱스의 키 값은 모두 정렬돼 있지만, 데이터 파일의 레코드는 정렬되지 않고 임의의 순서로 저장된다.
- 레코드가 삭제되어 빈 공간이 생기면 INSERT는 가능한 한 삭제된 공간을 재활용하도록 설계되었기 때문이다.

인덱스는 테이블의 키 칼럼만 가지고 있으므로 나머지 칼럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다.

MyISAM과 InnoDB의 인덱스 차이
- MyISAM 테이블은 세컨더리 인덱스가 물리적인 주소를 가진다.(ROWID)
- InnoDB 테이블은 프라이머리 키를 주소처럼 사용하기 때문에 논리적인 주소를 가진다고 볼 수 있다.

InnoDB 테이블에서 인덱스를 통해 레코드를 읽는 순서
1. 인덱스에 저장되어 있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한번더 검색한다.
2. 프라이머리 키 인덱스의 리프 페이지에 저장돼 있는 레코드를 읽는다.

InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서븐 반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한번 검색해야 한다.

### B-Tree 인덱스 키 추가 및 삭제
테이블의 레코드를 저장하거나 변경하는 경우 인덱스 키 추가나 삭제 작업이 발생한다.

#### 인덱스 키 추가
- B-Tree에 인덱스가 저장될 때 저장될 키 값을 이용해 B-Tree상의 적절한 위치(리프 노드)를 선택해야 한다.
- 리프 노드가 꽉 차서 저장할 수 없으면 리프 노드가 분리 되어야 한다.
    - 상위 브랜치 노드까지 처리의 범위가 넓어진다. 이러한 작업 탓에 B-Tree는 상대적으로 쓰기 작업(새로운 키 추가)에 비용이 많이 드는것으로 알려졌다.
- 인덱스 추가 비용은 대부분이 메모리와 CPU에서 처리하는 시간이 아니라 디스크로부터 인덱스 페이지를 읽고 쓰기를 해야 해서 걸리는 시간이다.
- MyISAM, MEMORY 스토리지 엔진은 INSERT가 실행되면 즉시 새로운 키 값을 B-Tree에 반영한다. InnoDB는 체인지 버퍼를 통해 인덱스 키 추가 작업을 지연시킬 수 있다.
    - 프라이머리 키나, 유니크 키는 중복 체크가 필요하기 때문에 즉시 B-Tree에 추가하거나 삭제한다.

#### 인덱스 키 삭제
- B-Tree의 리프 노드를 찾아서 삭제 마크만 하면 된다.
    - 삭제된 공간은 방치되거나 재활용 할 수 있다.
    - 디스크 I/O가 필요한 작업이다.
- MySQL 5.5 이상 버전의 InnoDB 스토리지 엔진에서는 이 작업도 버퍼링되어 지연처리 될 수 있다.
    - MyISAM, MEMORY는 체인지 버퍼와 같은 기능이 없으므로 인덱스 키 삭제과 완료된 후 쿼리 실행이 완료된다.

#### 인덱스 키 변경
- 인덱스 키 값은 값에 따라 저장될 리프 노드의 위치가 결정된다.
    - 따라서 인덱스 키 값은 값만 변경하는 것이 불가능하다.
- 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리된다.
    - 체인지 버퍼를 통해 지연 처리 될 수 있다.

#### 인덱스 키 검색
- INSERT, UPDATE, DELETE 작업시 인덱스 관리에 따른 추가 비용을 감당하면서 인덱스를 구축하는 이유
    - 빠른 검색을 위해서 비용을 감당한다.
- SELECT 뿐만 아니라, UPDATE, DELETE를 위한 검색에서도 사용한다.
- B-TRee 인덱스를 위한 검색은 100% 일치, 앞 부분만 일치하는 경우만 사용할 수 있다.
- 부등호(<, >) 비교 조건에서도 인덱스를 활용할 수 있지만, 인덱스를 구성하는 키 값의 뒷부분만 검색하는 용도로는 인덱스를 사용할 수 없다.
- 인덱스의 키 값에 변형을 가해진 후 비교되는 경우 B-Tree의 빠른 검색 기능을 사용할 수 없다.
    - 함수나 연산을 수행한 결과를 사용하면 인덱스를 사용할 수 없다.

InnoDB 스토리지 엔진에서 UPDATE, DELETE 문장을 실행 할 때 테이블에서 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠근다. 심지어 테이블의 모든 레코드를 잠글 수도 있다.

### B-Tree 인덱스 사용에 영향을 미치는 요소
칼럼의 크기, 레코드 건수, 유니크한 인덱스 키 값의 개수 등에 의해 검색이나 변경 작업의 성능이 영향을 받는다.

#### 인덱스 키 값의 크기
페이지(Page) 또는 블록(Block)
- InnoDB 스토리지 엔진에서 디스크의 모든 읽기 및 쓰기 작업의 최소 단위
- InnoDB 스토리지 엔진에서 버퍼 풀에서 데이터를 버퍼링 하는 기본 단위

MySQL 5.7 버전부터는 InnoDB 스토리지 엔진의 페이지 크기를 조절할 수 있다.
- innodb_page_size 시스템 변수를 사용하며 4KB ~ 64KB 사이의 값 선택 가능
    - 기본은 16KB

인덱스 크기에 따라 인덱스 페이지에 저장될 수 있는 인덱스 정보의 개수가 달라진다.
- 인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고, 그만큼 느려진다.
    - SELECT 쿼리 수행 시 페이지를 한 번 읽을 것을 두 번 읽어야 할 수 있다.

InnoDB의 버퍼풀, MyISAM의 키 캐시 영역의 크기가 제한되어 있다.
- 인덱스의 크기가 커지면 커질수록 메모리에 캐시해 둘 수 있는 레코드 수는 줄어든다.
    - 메모리의 효율이 떨어진다.

#### B-Tree 깊이
B-Tree의 깊이는 MySQL에서 값을 검색할 때 몇 번이나 랜덤하게 디스크를 읽어야 하는지와 직결되는 문제다.
- 인덱스 키 값의 크기가 커지면 커질수록 하나의 인덱스 페이지가 담을 수 잇는 인덱스 키 값의 개수가 적어진다.
    - 같은 레코드 건수라 하더라도 B-Tree의 깊이(Depth)가 깊어져서 디스크 읽기가 더 많이 필요하게 된다.

아무리 대용량 데이터베이스라도 B-Tree의 깊이(Depth)가 5단계 이상까지 깊어지는 경우는 흔치 않다.

#### 선택도(기수성)
선택도(Selectivity) 또는 기수성(Cardinality)
- 모든 인덱스 키 값 가운데 유니크한 값의 개수를 의미한다.
- 전체 인덱스 100개, 유니크한 값의 개수 10개면 기수성은 10이다.
- 인덱스 키 값 가운데 중복된 값이 많아질수록 기수성은 낮아지고 동시에 선택도가 떨어진다.
- 인덱스는 선택도가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리된다.

선택도가 높으면 불필요하게 읽는 레코드 수가 적어진다.
- 유니크한 값이 10개 vs 1000개일 경우, 10000건의 검색에서 불필요하게 읽는 값이 999 vs 9개가 된다.

#### 읽어야 하는 레코드의 건수
인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 더 높은 비용이 드는 작업이다.

인덱스를 통해 읽어야 할 레코드의 건수(옵티마이저가 판단한 예상 건수)가 전체 테이블 레코드의 20%~25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서 필요한 레코드만 가려내는(필터링) 방식으로 처리하는 것이 효율적이다.
- 일반적인 DBMS 옵티마이저는 인덱스를 통해 1건을 읽는 것이 테이블에서 직접 레코드를 통해 1건을 읽는 것보다 4~5배 더 많은 비용이 드는 작업인 것으로 예측한다.