## B-Tree 인덱스

### B-Tree 인덱스를 통한 데이터 읽기

#### 인덱스 레인지 스캔
인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다.

루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아 들어가야만 필요한 레코드의 시작 지점을 찾을 수 있다. 일단 시작해야 할 위치를 찾으면 그때부터는 리프 노드의 레코드만 순서대로 읽으면 된다.

인덱스 레인지 스캔은 해당 인덱스를 구성하는 칼럼의 정순 또는 역순으로 정렬된 상태로 레코드를 가져온다.
- 인덱스 자체의 정렬 특성 때문에 자동으로 정렬된 상태로 가져온다.

인덱스 레인지 스캔에서 인덱스의 리프 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요하다. 이 과정에서 랜덤 I/O가 한 번씩 일어난다.
- 3건의 레코드가 검색 조건에 일치하면 3번의 랜덤 I/O가 발생한다.
- 인덱스를 통해 데이터 레코드를 읽는 작업은 비용이 많이 든다.
    - 인덱스를 통해 읽어야 할 데이터 레코드가 20~25%를 넘으면 인덱스를 통한 읽기보다 테이블의 데이터를 직접 읽는 것이 더 효율적이다.

인덱스 레인지 스캔의 3단계
1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다.
    - 이 과정을 인덱스 탐색(index seek)이라고 한다.
2. 1번에서 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 쭉 읽는다.
    - 이 과정을 인덱스 스캔(index scan)이라고 한다.
3. 2번에서 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어온다.
    - 3번 과정이 필요 없는 경우도 있는데 이를 커버링 인덱스라고 한다.
        - 필요한 모든 컬럼 값이 인덱스에 포함되어 있어, 테이블 데이터를 추가로 읽지 않아도 된다.
        - 커버링 인덱스로 처리되는 쿼리는 디스크의 레코드를 읽지 않아도 되기 때문에 랜덤 I/O가 상당히 줄어들고 성능은 그만큼 빨라진다.

#### 인덱스 풀 스캔
인덱스 레인지 스캔과 달리 인덱스의 처음부터 끝까지 모두 읽는 방식

대표적으로 쿼리의 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우 인덱스 풀 스캔 방식이 사용된다.
- 인덱스가 A,B,C 순서대로 만들어져 있지만, 쿼리의 조건절에 B 칼럼이나 C 칼럼으로 검색하는 경우

일반적으로 인덱스의 크기는 테이블의 크기보다 작으므로 직접 테이블을 처음부터 끝까지 읽는 것보다 인덱스만 읽는 것이 효율적이다.
- 쿼리가 인덱스에 명시된 칼럼만으로 조건을 처리할 수 있는 경우 이 방식이 주로 사용된다.
    - 데이터 레코드까지 읽어야 한다면 절대 이 방식으로 처리되지 않는다.
- 즉, 인덱스 풀 스캔은 인덱스 레인지 스캔보다는 빠르지 않지만 테이블 풀 스캔보다는 효율적이다.
- 인덱스의 전체 크기는 테이블 자체의 크기보다는 훨씬 작으므로 인덱스 풀 스캔은 테이블 전체를 읽는 것보다는 적은 디스크 I/O로 쿼리를 처리할 수 있다.

#### 루스 인덱스 스캔
- 오라클과 같은 DBMS의 "인덱스 스킵 스캔" 기능과 작동 방식이 비슷하다.
- 인덱스 레인지 스캔, 인덱스 풀 스캔은 타이트(Tight) 인덱스 스캔인 것과 달리, 루스 인덱스 스캔은 말 그대로 느슨하게(또는 듬성듬성) 인덱스를 읽는것을 의미한다.

루스 인덱스 스캔은 인덱스 레인지 스캔과 비슷하게 작동하지만 중간에 필요치 않은 인덱스 키 값은 무시(SKIP)하고 다음으로 넘어가는 형태로 처리한다.
- 일반적으로 GROUP BY 또는 집합 함수 가운데 MAX() 또는 MIN() 함수에 대해 최적화를 하는 경우에 사용된다.

```sql
SELECT dept_no, MIN(emp_no)
FROM dept_emp
WHERE detp_no BETWEEN 'd002' AND 'd004'
GROUP BY dept_no;
```

(dept_no, emp_no)로 인덱스가 생성되어 있다. 이 인덱스는 (dept_no, emp_no) 순으로 정렬되어 있어서 dept_no 그룹별로 첫 번째 레코드의 emp_no만 읽으면 된다.
- WHERE 조건을 만족하는 범위 전체를 다 스캔할 필요가 없다.
    - 불필요한 부분은 무시하고 필요한 부분만 읽으면 된다.
- dept_no별로(d002~d004) 첫 번째의 emp_no만 읽으면 된다.

#### 인덱스 스킵 스캔
인덱스의 핵심
- 값이 정렬되어 있다.
- 인덱스를 구성하는 칼럼의 순서가 매우 중요하다.

인덱스 생성
```sql
ALTER TABLE employees ADD INDEXix_gender_birthdate (gender, birth_date);
```

위 인덱스를 사용하려면 WHERE 조건절에 gender 칼럼에 대한 비교 조건이 필수이다.

```sql
-- // 인덱스를 사용하지 못함
SELECT * FROM employees WHERE birth_date>='1965-02-01'

-- // 인덱스를 사용
SELECT * FROM employees WHERE gender='M' AND birth_date>='1965-02-01'
```

MySQL 8.0 버전부터 옵티마이저가 gender 칼럼을 건너뛰어서 birth_date 칼럼만으로도 인덱스 검색이 가능하게 해주는 인덱스 스킵 스캔(Index skip scan) 최적화 기능 도입
- 루스 인덱스 스캔도 비슷한 최적화를 수행하지만, GROUP BY 작업을 처리하기 위해 인덱스를 사용하는 경우에만 적용 가능하다.

인덱스 스킵 스캔 기능이 비활성화 된 상태의 실행계획
```sql
SET optimizer_switch='skip_scan=off';

EXPLAIN 
SELECT gender, birth_date
FROM employees
WHERE birth_date>='1965-02-01'
```

id | table | type | key | Extra |
---|-------|------|-----|-------|
1 | employees | index | ix_gender_birth_date | Using where: Using index |

WHERE 조건절에 gender 칼럼에 대한 조건 없이 birth_date 칼럼의 비교 조건만 가지고 있어서 인덱스를 효율적으로 이용할 수 없다.
- 인덱스에서 꼭 필요한 부분만 접근하는 방법을 사용하지 못한다.
- type이 index라는 것은 풀 인덱스 스캔을 의미한다.
- 위 쿼리는 인덱스에 있는 gender, birth_date 칼럼만 있으면 처리를 완료할 수 있기 때문에 ix_gender_birthdate 인덱스를 풀 스캔하였다.(커버링 인덱스)
    - 만약 SELECT에서 employees 테이블의 모든 칼럼을 가져와야 했다면 테이블 풀 스캔을 수행했을 것이다.

인덱스 스킵 스캔을 활성화 된 상태에서 실행계획
```sql
SET optimizer_switch='skip_scan=on';

EXPLAIN
SELECT gender, birth_date
FROM employees
WHERE birth_date>='1965-02-01';
```

id | table | type | key | Extra |
---|-------|------|-----|-------|
1 | employees | range | ix_gender_birth_date | Using where: Using index for skip scan |

- type 값이 range로 표시됨
    - 인덱스에서 필요한 부분만 읽었다는 것을 의미한다.
- Extra 칼럼에 표시된 문구
    - ix_gender_birthdate 인덱스에 대해 인덱스 스킵 스캔을 활용해 데이터를 조회했다는 것을 의미한다.
- MySQL 옵티마이저는 우선 gender 칼럼에서 유니크한 값을 모두 조회해서 주어진 쿼리에 gender 칼럼의 조건을 추가해서 쿼리를 다시 실행하는 형태로 처리한다. (M, F)
```sql
SELECT gender, birth_date FROM employees WHERE gender='M' AND birth_date>='1965-02-01';
SELECT gender, birth_date FROM employees WHERE gender='F' AND birth_date>='1965-02-01';
```

인덱스 스킵 스캔의 단점
- WHERE 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 함
    - 유니크한 값의 개수가 매우 많다면 MySQL 옵티마이저는 인덱스에서 스캔해야 할 시작 지점을 검색하는 작업이 많이 필요해진다. (쿼리 처리 성능이 오히려 더 느려질 수도 있다.)
- 쿼리가 인덱스에 존재하는 칼럼으로만 처리 가능해야 함(커버링 인덱스)

두 번째 경우의 예시
```sql
EXPLAIN
SELECT * 
FROM employees
WHERE birth_date>='1965-02-01';
```

id | table | type | key | rows | Extra |
---|-------|------|-----|-------|------|
1 | employees | ALL | NULL | 300363 | Using where |

- 커버링 인덱스가 아니라서 테이블 풀 스캔이 발생

### 다중 칼럼(Multi-column) 인덱스
두 개 이상의 칼럼으로 구성된 인덱스를 다중 칼럼 인덱스(또는 복합 칼럼 인덱스)라고 한다.
- 또한 2개 이상의 칼럼이 연결됐다고 해서 "Concatenated Index"라고도 한다.

루트 노드와 리프 노드는 항상 존재한다.
- 브랜치 노드는 없는 경우가 있을 수도 있따.

인덱스의 두 번째 칼럼은 첫 번째 칼럼에 의존해서 정렬돼 있다.
- 즉, 두 번째 칼럼의 정렬은 첫 번째 칼럼이 똑같은 레코드에서만 의미가 있다.
- dept_no, emp_no의 경우 emp_no 값의 정렬 순서가 빠르더라도, demp_no 칼럼의 정렬 순서가 늦다면 인덱스 뒤쪽에 위치한다.
- 다중 칼럼 인덱스에서는 인덱스 내에서 각 칼럼의 위치(순서)가 상당히 중요하다.
    - 아주 신중히 결정해야 한다.