## B-Tree 인덱스

### B-Tree 인덱스의 가용성과 효율성
- 쿼리의 WHERE, GROUP BY, ORDER BY 절이 어떤 경우에 인덱스를 사용할 수 있고 어떤 방식으로 사용할 수 있는지 식별해야 한다.
    - 쿼리의 조건을 최적화 하거나, 쿼리에 맞게 인덱스를 최적으로 생성할 수 있다.

#### 비교 조건의 종류와 효율성
다중 칼럼 인덱스에서 각 칼럼의 순서와 그 칼럼에 사용된 조건이 동등 비교(=) 또는 범위 조건(>, <)인지에 따라 각 인덱스 칼럼의 활용 형태 및 효율이 달라진다.

```sql
SELECT * FROM dept_emp
WHERE dept_no='d002' AND emp_no >= 10114;
```
위의 쿼리에 대하여 다음과 같이 인덱스 생성
- 케이스 A: INDEX (dept_no, emp_no)
- 케이스 B: INDEX (emp_no, dept_no)

케이스 A는 비교 작업의 범위를 좁히는데 도움을 준다.
- emp_no는 비교 작업의 범위를 좁히는데 도움을 준다.
- dept_no가 d002이고, emp_no가 10114이상인 레코드를 찾고, dept_no가 d003일 때 까지만 레코드를 읽으면 된다.

케이스 B는 비교 작업의 범위를 좁히는데 도움을 주지 못한다.
- dept_no는 쿼리의 조건에 맞는지 검사하는 용도로만 사용

작업 범위 결정 조건과 필터링 조건
- 작업 범위 결정 조건
    - 작업의 범위를 결정
    - 케이스 A의 dept_no, emp_no, 케이스 B의 emp_no
- 필터링 조건
    - 비교 작업의 범위를 줄이지 못하고 단순히 필터링 역할만 함
    - 케이스 B의 dept_no

작업 범위를 결정하는 조건은 많으면 많을수록 쿼리의 처리 성능을 높이지만 체크 조건은 ㅁ낳다고 해서 쿼리의 처리 성능을 높이지는 못한다. 오히려 쿼리 실행을 더 느리게 만들 때가 많다.

#### 인덱스의 가용성
B-Tree의 인덱스의 특징
- 왼쪽 값에 기준해서(Left-most) 오른쪽 값이 정렬되어 있다.
- 하나의 칼럼 내에서 뿐만 아니라 다중 칼럼 인덱스의 칼럼에 대해서도 적용된다.

하나의 칼럼으로 검색해도 값의 왼쪽 부분이 없으면 인덱스 레인지 스캔의 방식의 검색이 불가능하다.
```sql
-- // 왼쪽 부분이 고정되지 않아 인덱스를 사용할 수 없음
SELECT * FROM employees WHERE first_name LIKE '%mer';
```

다중 칼럼 인덱스에서 왼쪽 칼럼의 값을 모르면 인덱스 레인지 스캔을 사용할 수 없다.
```sql
-- // 
SELECT * FROM dept_emp WHERE emp_no>=10144;
```
- 인덱스가 (dept_no, emp_no) 칼럼 순서대로 생성이 되어 있다면 인덱스의 선행 칼럼인 dept_no 조건 없이 emp_no 값으로만 검색하면 인덱스를 효율적으로 사용할 수 없다.
    - 다중 칼럼 인덱스이므로 dept_no 칼럼에 대해 먼저 정렬한 후, emp_no로 정렬되어 있기 때문이다.

인덱스 왼쪽 값 기준은 WHERE 조건절 뿐만 아니라, GROUP BY, ORDER BY 절에도 똑같이 적용된다.

#### 가용성과 효율성 판단
B-Tree 인덱스를 사용할 수 없는 조건(작업 범위 결정 조건으로 사용 못하지만 경우에 따라 체크 조건으로 인덱스 사용)
- NOT-EQUAL로 비교된 경우 (<>, NOT IN, NOT BETWEEN, IS NOT NULL)
- LIKE '%??'(앞 부분이 아닌 뒷부분 일치) 형태로 문자열 패턴이 비교된 경우
- 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교된 경우
- NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
- 데이터 타입이 서로 다른 비교(인덱스 칼럼의 타입을 변환해야 비교가 가능한 경우)
- 문자열 데이터 타입의 콜레이션이 다른 경우

```sql
-- // MySQL에서는 NULL 값도 인덱스에 저장, 아래와 같은 WHERE 조건도 작업 범위 결정 조건으로 인덱스 사용
.. WHERE column IS NULL ..
```

다중 칼럼으로 만들어진 인덱스의 사용 조건
```sql
INDEX ix_test (column_1, column_2, column_3, ... column_n)
```
- 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
    - column_1 칼럼에 대한 조건이 없는 경우
    - column_1 칼럼의 비교 조건이 인덱스를 사용할 수 없는 조건인 경우
- 작업 범위 결정 조건으로 인덱스를 사용하는 경우
    - column_1 ~ column_(i-1) 칼럼까지 동등 비교 형태(=, IN) 비교
    - column_i 칼럼에 대해서는 다음 연산자 중 하나로 비교
        - 동등 비교(=, IN)
        - 크다 작다 형태(>, <)
        - LIKE로 좌측 일치 패턴(LIKE '승환%')