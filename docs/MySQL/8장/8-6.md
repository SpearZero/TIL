## 클러스터링 인덱스
- MySQL 서버에서 클러스터링은 테이블의 레코드를 프라이머리 키를 기준으로 묶어서 저장하는 형태로 구현
    - 비슷한 값을 동시에 조회하는 경우가 많다는 점에서 착안
- InnoDB 스토리지 엔진에서만 지원

### 클러스터링 인덱스
- 프라이머리 키에 대해서만 적용
- 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장
- 프라이머리 키 값에 의해 레코드의 저장 위치가 결정된다.
    - 프라이머리 키 값이 변경되면 그 레코드의 물리적인 위치까지 변경되어야 한다.
- 클러스터링의 기준이 되는 프라이머리 키는 클러스터링 키라고도 표현
- 클러스터링 인덱스로 저장되는 테이블은 프라이머리 키 기반의 검색이 매우 빠르며, 대신 레코드의 저장이나 프라이머리 키의 변경이 상대적으로 느리다.
- 테이블의 레코드가 프라이머리 키 값으로 정렬되어 저장된 경우만 '클러스터링 인덱스' 또는 '클러스털이 테이블'이라고 한다.

클러스터링 인덱스의 리프 노드에는 레코드의 모든 칼럼이 저장되어 있다.
- 클러스터링 테이블은 그 자체가 하나의 거대한 인덱스 구조로 관리되어 있음

클러스터링 테이블에서 프라이머리 키 값이 변경되면 레코드의 위치가 변경된다.
- MyISAM이나 InnoDB를 제외한 테이블의 데이터 레코드는 프라이머리 키나 인덱스키 값이 변경된다고 해서 실제 데이터 레코드의 위치가 변경되지 않는다.

프라이머리 키가 없는 경우 InnoDB의 클러스터링 테이블 구성 방법
- InnoDB 스토리지 엔진이 프라이머리 키를 대체할 칼럼을 선택한다.

프라이머리 키를 대체할 칼럼을 선택하는 순서
1. 프라이머리 키 존재시 프라이머리 키 선택
2. NOT NULL 옵션의 유니크 인덱스 중 첫 번째 인덱스를 클러스터링 키로 선택
3. 자동으로 유니크한 값을 가지도록 증가되는 칼럼을 내부적으로 추가한 후, 클러스터링 키로 선택

자동으로 증가된 프라이머리 키는 사용자에게 노출되지 않으며, 쿼리 문장에서 명시적으로 사용할 수 없다.
- 프라이머리 키를 명시적으로 생성하는 것이 좋다.

### 세컨더리 인덱스에 미치는 영향
- MyISAM, MEMORY 테이블 같은 클러스터링되지 않은 테이블은 INSERT될 때 처음 저장된 공간에서 절대 이동하지 않는다.
    - 데이터가 레코드가 저장된 주소는 내부적인 레코드 아이디(ROWID) 역할을 한다.
    - 프라이머리 키, 세컨드 인덱스의 각 키는 ROWID를 이용해 실제 데이터 레코드를 찾아온다.
        - 구조적으로 프라이머리 키와 세컨더리 인덱스는 차이가 없다.

InnoDB의 세컨더리 인덱스가 실제 레코드가 저장된 주소를 가지고 있지 않는 이유
- 오버헤드를 제거하기 위해
- 만약 세컨더리 인덱스가 실제 레코드 주소를 가지고 있다면, 클러스터링 키 값이 변경될 때마다 데이터 레코드의 주소가 변경되고 그때마다 해당 테이블의 모든 인덱스에 저장된 주솟값을 변경해야 한다.

InnoDB의 세컨더리 인덱스는 해당 레코드가 저장된 주소가 아닌 프라이머리 키 값을 저장한다.

### 클러스터링 인덱스의 장점과 단점
- 장점
    - 프라이머리 키(클러스터링 키)로 검색시 성능이 매우 빠르다.(프라이머리 키 범위 검색시 매우 빠르다.)
    - 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많다.(커버링 인덱스)
- 단점
    - 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적인 인덱스 크기가 커짐
    - 세컨더리 인덱스 검색시 프라이머리 키로 다시 한 번 검색해야 한다.
    - INSERT시 프라이머리 키에 의해 레코드의 저장 위치가 결졍되기 때문에 성능이 느리다.
    - 프라이머리 키 변경시 DELETE 후 INSERT하는 작업이 필요하기 때문에 처리 성능이 느리다.

읽기 성능을 위해 쓰기가 느려진다.
- 대부분의 경우 읽기, 쓰기 비율이 8:2, 9:1 이기 때문에, 읽기를 빠르게 유지하는것이 중요하다.

### 클러스터링 테이블 사용시 주의사항

#### 클러스터링 인덱스 키의 크기
프라이머리 키의 크기가 커지면 세컨더리 인덱스도 자동으로 크기가 커진다.
- 레코드 한 건은 작을수 있으나, 레코드가 많이 쌓이면 저장되는 크기가 많이 차이난다.

#### 프라이머리 키는 AUTO-INCREMENT보다는 업무적인 칼럼으로 생성(가능한 경우)
- 프라이머리 키로 검색하는 경우(특히 범위로 많은 레코드를 검색하는 경우) 클러스터링되지 않은 테이블에 비해 매우 빠르게 처리된다.
- 프라이머리 키는 중요한 역할을 하기 때문에 대부분 검색에서 상당히 빈번하게 사용되는 것이 일반적이다.
    - 따라서, 칼럼의 크기가 크더라도 업무적으로 해당 레코드를 대표할 수 있다면 그 칼럼을 프라이머리 키로 설정하는 것이 중요

#### 프라이머리 키는 반드시 명시할 것
- AUTO_INCREMENT 칼럼을 이용해서라도 프라이머리 키를 생성해야 한다.
- 내부적으로 생성되는 프라이머리 키는 사용자가 사용할 수 없다.
- ROW 기반의 복제나 InnoDB Cluster에서는 모든 테이블이 프라이머리 키를 가져야만 정상적인 복제 성능을 보장한다.

#### AUTO-INCREMENT 칼럼을 인조 식별자로 사용할 경우
- 세컨더리 인덱스도 필요하고, 프라이머리 키의 크기도 길다면 AUTO_INCREMENT 칼럼을 추가하고 이를 프라이머리 키로 설정
- INSERT 위주의 테이블에 인조 식별자를 프라이머리 키로 설정하는 것은 성능 향상에 도움이 된다.
    - 인위적으로 추가한 프라이머리 키를 인조 식별자(Surrogate key)라고 한다.