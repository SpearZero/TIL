## 고급 최적화

#### MRR과 배치 키 액세스(mrr & batched_key_access)
- MRR(Multi-Range Read)
    - 인덱스 스캔 시 디스크 접근을 최소화하려고 필요한 레코드를 정렬된 블록 단위로 모아 한 번에 읽는 최적화 기법
- BKA(Batched Key Access)
    - MRR을 응용해서 실행되는 조인 방식
    - 기본적으로 비활성화

#### 블록 네스티드 루프 조인(block_nested_loop)
- 네스티드 루프 조인(Nested Loop join)
    - MySQL 서버에서 사용되는 대부분의 조인
    - 조인의 연결 조건이 되는 칼럼에 모두 인덱스가 있는 경우 사용되는 조인 방식
- 블록 네스티드 루프 조인(Block Nested Loop Join)
    - 조인 버퍼(join buffer)를 사용한다.

조인 설명
- 드라이빙 테이블에서 일치하는 레코드의 건수만큼 드리븐 테이블을 검색하며 처리
    - 드리븐 테이블의 조인 조건이 인덱스를 이용할 수 없다면 드라이빙 테이블 레코드 건수만큼 드리븐 테이블 풀 스캔
- 옵티마이저는 최대한 드리븐 테이블의 검색이 인덱스를 사용할 수 있게 실행 계획을 수립한다.

조인 버퍼
- 드리븐 테이블의 풀 테이블 스캔, 인덱스 풀 스캔을 피할수 없다면 사용
- 드라이빙 테이블에서 읽은 레코드를 메모리에 캐시한 후 드리븐 테이블과 메모리 캐시를 조인하는 형태로 처리
    - 이 메모리 캐시를 조인 버퍼(Join buffer)라고 한다.

조인이 수행된 후 가져오는 결과는 드라이빙 테이블에 의해 순서가 결정되지만, 조인 버퍼가 사용되는 조인에서는 결과의 정렬 순서가 흐트러질 수 있다.

#### 인덱스 컨디션 푸시다운(index_condition_pushdown)
MySQL이 인덱스 레인지 스캔 시, WHERE 절 조건 중 인덱스를 범위 제한 조건으로 사용하지 못하더라도, 해당 조건이 인덱스에 포함된 칼럼이라면 스토리지 엔진(디스크)까지 푸시해서 먼저 검사함으로써 불필요한 레코드 읽기를 줄이는 최적화 기법
```sql
-- // last_name, first_name 복합 인덱스, first_name은 인덱스를 사용할 수 없음
-- // 인덱스 푸시 다운을 사용해 최대한 필터링을 완료해서 필요한 레코드 1건에 대해서만 테이블 읽기 수행 가능
SELECT * FROM employees WHERE last_name='Acton' AND first_name LIKE '%sal';
```
쿼리의 성능이 몇 배에서 몇십 배로 향상될 수도 있는 중요한 기능이다.

#### 인덱스 확장(use_index_extensions)
- use_index_extensions 옵티마이저 옵션
    - InnoDB 스토리지 엔진을 사용하는 테이블에서 세컨더리 인덱스에 자동으로 추가된 프라이머리 키를 활용할 수 있게 할지를 결정하는 옵션
- PRIMARY KEY (dept_no, emp_no), KEY ix_fromdate (from_date) 예시
    - ix_fromdate 인덱스는 (from_date, dept_no, emp_no) 조합으로 인덱스를 생성한 것과 흡사하게 작동
