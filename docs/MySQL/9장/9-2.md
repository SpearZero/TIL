## 고급 최적화

#### MRR과 배치 키 액세스(mrr & batched_key_access)
- MRR(Multi-Range Read)
    - 인덱스 스캔 시 디스크 접근을 최소화하려고 필요한 레코드를 정렬된 블록 단위로 모아 한 번에 읽는 최적화 기법
    - 드라이빙 테이블의 레코드를 읽어서 드리븐 테이블과의 조인을 즉시 실행하지 않고 조인 대상을 버퍼링
- BKA(Batched Key Access)
    - MRR을 응용해서 실행되는 조인 방식
    - 기본적으로 비활성화

#### 블록 네스티드 루프 조인(block_nested_loop)
- 네스티드 루프 조인(Nested Loop join)
    - MySQL 서버에서 사용되는 대부분의 조인
    - 조인의 연결 조건이 되는 칼럼에 모두 인덱스가 있는 경우 사용되는 조인 방식
- 블록 네스티드 루프 조인(Block Nested Loop Join)
    - 조인 버퍼(join buffer)를 사용한다.

조인 설명
- 드라이빙 테이블에서 일치하는 레코드의 건수만큼 드리븐 테이블을 검색하며 처리
    - 드리븐 테이블의 조인 조건이 인덱스를 이용할 수 없다면 드라이빙 테이블 레코드 건수만큼 드리븐 테이블 풀 스캔
- 옵티마이저는 최대한 드리븐 테이블의 검색이 인덱스를 사용할 수 있게 실행 계획을 수립한다.

조인 버퍼
- 드리븐 테이블의 풀 테이블 스캔, 인덱스 풀 스캔을 피할수 없다면 사용
- 드라이빙 테이블에서 읽은 레코드를 메모리에 캐시한 후 드리븐 테이블과 메모리 캐시를 조인하는 형태로 처리
    - 이 메모리 캐시를 조인 버퍼(Join buffer)라고 한다.

조인이 수행된 후 가져오는 결과는 드라이빙 테이블에 의해 순서가 결정되지만, 조인 버퍼가 사용되는 조인에서는 결과의 정렬 순서가 흐트러질 수 있다.

#### 인덱스 컨디션 푸시다운(index_condition_pushdown)
MySQL이 인덱스 레인지 스캔 시, WHERE 절 조건 중 인덱스를 범위 제한 조건으로 사용하지 못하더라도, 해당 조건이 인덱스에 포함된 칼럼이라면 스토리지 엔진(디스크)까지 푸시해서 먼저 검사함으로써 불필요한 레코드 읽기를 줄이는 최적화 기법
```sql
-- // last_name, first_name 복합 인덱스, first_name은 인덱스를 사용할 수 없음
-- // 인덱스 푸시 다운을 사용해 최대한 필터링을 완료해서 필요한 레코드 1건에 대해서만 테이블 읽기 수행 가능
SELECT * FROM employees WHERE last_name='Acton' AND first_name LIKE '%sal';
```
쿼리의 성능이 몇 배에서 몇십 배로 향상될 수도 있는 중요한 기능이다.

#### 인덱스 확장(use_index_extensions)
- use_index_extensions 옵티마이저 옵션
    - InnoDB 스토리지 엔진을 사용하는 테이블에서 세컨더리 인덱스에 자동으로 추가된 프라이머리 키를 활용할 수 있게 할지를 결정하는 옵션
- PRIMARY KEY (dept_no, emp_no), KEY ix_fromdate (from_date) 예시
    - ix_fromdate 인덱스는 (from_date, dept_no, emp_no) 조합으로 인덱스를 생성한 것과 흡사하게 작동

#### 인덱스 머지
- 대부분의 옵티마이저는 테이블당 하나의 인덱스만 사용.
- Index Merge는 한 테이블에서 여러 인덱스를 동시에 활용하는 실행 계획.
- 일반적으로 하나의 인덱스만으로도 충분히 효율적이기 때문에 기본 전략.
    - 서로 다른 조건이 각기 다른 인덱스를 사용할 수 있고, 각 조건의 결과 레코드 수가 많을 경우,
Index Merge 전략 선택

인덱스 머지의 실행 계획
- index_merge_itersection
- index_merge_sort_union
- index_merge_union

#### 인덱스 머지 - 교집합(index_merge_intersection)
- Extra 칼럼에 "Using intesect" 표시
    - 쿼리가 여러 개의 인덱스를 각각 검색해서 그 결과의 교집합만 반환
    ```sql
    -- // first_name과 emp_no(PK)에 둘다 인덱스 존재
    SELECT * FROM employees 
    WHERE first_name='Georgi' AND emp_no BETWEEN 10000 AND 20000;
    ```
- 인덱스를 하나만 사용하고 싶으면 index_merge_intersection 최적화 비활성화 가능
    - MySQL 서버 전체에 적용하는것이 불안하다면 현재 커넥션 또는 현재 쿼리에 비활성화 하는 것도 가능하다.

#### 인덱스 머지 - 합집합(index_merge_union)
- WHERE 절에 사용된 2개의 이상의 조건이 각각의 인덱스를 사용하고 OR 연산자로 연결된 경우 사용되는 최적화
```sql
SELECT * FROM employees
WHERE first_name='Matt' OR hire_date='1987-03-31'
```
- Using union(ix_first_name, ix_hiredate)로 표시됨
    - 각각의 인덱스 결과를 'Union' 알고리즘으로 병합
- 각각의 쿼리를 프라이머리 키로 정렬 후, 정렬된 두 집합의 결과를 하나씩 가져와 중복 제거를 한다.
    - emp_no(PK) 값이 중복된 레코드들을 정렬 없이 걸러낸다.
    - 우선순위 큐 알고리즘 사용

#### 인덱스 머지 - 정렬 후 합집합(index_merge_sort_union)
- 인덱스 머지 작업을 하는 도중에 결과의 정렬이 필요한 경우 'Sort union' 알고리즘을 사용한다.
```sql
SELECT * FROM employees 
WHERE first_name='Matt' OR hire_date BETWEEN '1987-03-01' AND '1987-03-31'

-- // emp_no로 정렬되어 출력
SELECT * FROM employees WHERE first_name='Matt';
-- // emp_no 칼럼으로 정렬되지 않음
SELECT * FROM employees WHERE hire_date BETWEEN '1987-03-01' AND '1987-03-31'
```
- 우선순위 큐 알고리즘을 사용할 수 없다.
    - 두 집합의 중복을 제거하기 위해 각 집합을 emp_no 칼럼으로 정렬한 다음 중복 제거 수행
    - Using sort_union(ix_firstname, ix_hiredate);

#### 세미 조인(semijoin)
- 다른 테이블과 실제 조인을 수행하지는 않고, 단지 다른 테이블에서 조건에 일치하는 레코드가 있는지 없는지만 체크하는 형태의 쿼리
- MySQL 5.7 서버는 세미조인 형태의 쿼리를 최적화 하는 부분이 취약
```sql
-- // MySQL 서버는 employees 테이블을 풀 스캔하면서 한 건 한 건 서브쿼리의 조건에 일치하는지 비교
SELECT * FROM employees e
WHERE e.emp_no 
IN (SELECT de.emp_no FROM dept_emp de WHERE de.from_date='1995-01-01')
```
- MySQL 8.0 버전부터 세미 조인 쿼리의 성능을 개선하기 위한 최적화 전략 존재
    - Table Pull-out
        - 세미 조인의 서브쿼리에 사용된 테이블을 아우터 쿼리로 끄집어낸 후에 쿼리를 조인 쿼리로 재작성하는 형태의 최적화
    - Duplicate Weed-out
        - 세미 조인 서브쿼리를 일반적인 INNER JOIN 쿼리로 바꿔서 실행하고 마지막에 중복된 레코드를 제거하는 방법으로 처리되는 최적화 알고리즘
    - First Match
        - IN(subquery) 형태의 세미 조인을 EXISTS(subquery) 형태로 튜닝한 것과 비슷한 방법으로 실행
    - Loose Scan
        - 인덱스를 사용하는 GROUP BY 최적화(Using index for group_by)의 루스 인덱스 스캔(Loose Index Scan)과 비슷한 읽기 방식 사용
    - Materialization
        - 세미 조인에 사용된 서브쿼리를 통째로 구체화해서 쿼리를 최적화
        - 구체화는 쉽게 표현하면 내부 임시 테이블을 생성한다는 것을 의미
    
#### 컨디션 팬아웃(condition_fanout_filter)
- condition_fanout_filter 최적화 기능 활성화시
    - MySQL 옵티마이저는 더 정교한 계산을 걸쳐서 실행 계획 수립
        - 실행 계획 수립에 더 많은 시간과 컴퓨팅 자원 사용
- 쿼리가 간단하고 MySQL 8.0 이전 버전에서도 쿼리 실행 계획이 잘못된 선택을 한적이 별로 없다면 condition_fanout_filter 최적화는 성능 향상에 크게 도움이 되지 않을 수 있음

#### 파생 테이블 머지(derived_merge)
- 예전 버전의 MySQL 서버에서는 FROM 절에 사용된 쿼리는 먼저 실행해서 그 결과를 임시 테이블로 만든 다음 외부 쿼리 부분 처리
    - 임시테이블에 값을 INSERT 하고 읽는 것은 복사하고 읽는 오버헤드가 추가 된다.
    - 임시 테이블은 처음에 메모리 영역에 생성되지만, 레코드 건수가 많아지면 디스크로 기록되어야 한다.
        - 임시 테이블의 크기가 메모리에 상주할 만큼 작다면 성능에 큰 영향을 미치지 않음
        - 레코드가 많아지면 임시 테이블로 레코드를 복사하고 읽는 오버헤드로 인해 쿼리의 성능이 느려진다.
- MySQL 5.7 버전부터는 파생 테이블로 만들어지는 서브쿼리를 외부 쿼리와 병합해서 서브쿼리 부분을 제거하는 최적화 도입
    - derived_merge 최적화 옵션은 이러한 임시 테이블 최적화를 활성화할지 여부를 결정

#### 인비저블 인덱스(use_invisible_indexes)
MySQL 8.0 버전부터 인덱스를 삭제하지 않고, 해당 인덱스를 사용하지 못하게 제어하는 기능 제공

#### 스킵 스캔
인덱스의 핵심
- 값이 정렬되어 있음
- 인덱스를 구성하는 칼럼의 순서가 중요하다.
- (A, B, C) 인덱스의 경우 WHERE절 예시
    - A, B 칼럼에 대한 조건이 있다면 A,B 칼럼만 인덱스 활용
    - A 칼럼에 대한 ㅈ건만 있다면 A 칼럼까지만 인덱스 활용
    - B와 C 칼럼에 대한 조건이 있다면 인덱스 활용 불가

```sql
ALTER TABLE employees ADD INDEXix_gender_birthdate (gender, birth_date);

-- // ix_birth_date 인덱스 활용 불가
SELECT * FROM employees WHERE birth_date >= '1965-02-01';

-- // ix_birth_date 인덱스 활용 가능
SELECT * FROM employees WHERE gender='M' AND birth_date >= '1965-02-01';
```
- MySQL 8.0 버전부터 인덱스 스킵 스캔 최적화 도입
    - 인덱스의 선행 칼럼이 조건절에 사용되지 않더라도 후행 칼럼의 조건만으로 인덱스를 이용한 쿼리 성능 개선이 가능
    - 위의 예시에서 첫 번째 쿼리에서 MySQL 8.0 버전의 옵티마이저는 테이블에 존재하는 모든 gender 칼럼의 값을 가져와 두 번째 쿼리와 같이 gender 칼럼의 조건이 있는 것처럼 쿼리를 최적화
- 인덱스의 선행 칼럼이 매우 다양한 값을 가지는 경우는 인덱스 스킵 스캔 최적화가 비효율적일 수 있다.
    - MySQL 8.0 옵티마이저는 인덱스의 선행 칼럼이 소수의 유니크한 값을 가질때만 인덱스 스킵 스캔 최적화 사용
- 인덱스 스킵 스캔 최적화의 활성화 여부를 제어할 수 있다.