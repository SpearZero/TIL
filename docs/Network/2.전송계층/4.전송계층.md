## 전송 계층

TCP
- 프로세스와 프로세스 사이의 물리적인 연결
- TCP는 운영체제 내부에 구현되어 있다.
- 머신안에 많은 TCP 소켓이 있으며 전송버퍼와 수신버퍼 한 쌍을 다 가지고 있다.
- window size
    - 피드백 없이 한 번에 보낼 수 있는 크기
    - 타이머로 세그먼트 유실을 판단한다.
        - rtt 측정값의 평균값 + 마진값
    - 여러 세그먼트에서 똑같은 ACK 번호를 전달하면 세그먼트가 유실되었다고 판단할 수 있다.
- 수신 버퍼에 있는 세그먼트는 read 할때 어플리케이션 계층으로 올라간다.
- 애플리케이션 계층에서 write시에 송신 버퍼에 내려간다.

flow control(흐름 제어)
- 애플리케이션 계층에서 read를 천천히 하면 수신 버퍼에서 세그먼트를 늦게 가져간다.
    - 수신버퍼에 데이터가 쌓이게 된다.
    - 버퍼도 용량 제한이 있음
    - 송신측은 수신측의 버퍼를 고려해서 데이터를 보내야 한다.
    - 수신측은 자신의 버퍼 상태를 송신측에 알려줘야 함
        - 리시브 윈도우 값을 송신측에 알려준다.
        - 세그먼트 헤더에 윈도우 정보를 위한 필드가 있다.(receive window)
        - receive window 값이 2000바이트면 상대 측 송신 버퍼의 window size는 2000바이트로 줄어든다. (수신측의 수신 버퍼에 의존적이다.)

수신측에서 read를 안해서 receive window가 0인 경우
- 수신 버퍼에 새로운 공간이 날 때 까지 데이터를 안보내면 된다.
- 후에 수신 버퍼에 300바이트의 공간이 남았지만 송신측에서 세그먼트가 오지 않아 피드백을 보낼 수 없다.
    - 송신버퍼에 있는 데이터를 보낼 때, 응답으로 receive window 사이즈를 알려 줄 수 있다.
- 세그먼트를 보내는 방법
    - wirte로 송신 버퍼에 있는 데이터를 보냄
    - 상대방에서 세그먼트가 와서 ACK를 보낼 때
- wirte 버퍼가 비어있고, ACK를 보낼 수 없는 경우
    - 수신측의 receive window 사이즈가 0인 경우 송신측에서 주기적으로 작은 크기의 세그먼트를 보내본다.(40바이트 헤더 + 1바이트 데이터)
        - 수신 버퍼가 비었다면 데이터를 보내면 된다.

세그먼트 사이즈 결정
- 세그먼트 사이즈가 크면
    - 헤더의 크기는 40바이트로 정해져 있음
    - 데이터 부분에 100바이트를 넣던, 1바이트를 넣던 헤더 크기는 고정임
    - 세그먼트 사이즈가 클 수록 오버헤드가 줄어든다.
    - 애플리케이션 계층에서 write를 천천히 하면 하나의 세그먼트 데이터를 채우는데 오랜 시간이 걸린다.
    - 첫 번째 세그먼트는 무조건 전송함
        - 피드백이 올 때까지 송신버퍼에 데이터가 축적됨
        - ACK가 오기전에 설정한 세그먼트 사이즈가 꽉차면 데이터를 보낸다.
        - 송신 버퍼가 꽉 차지 않으면 ACK가 도착하면 송신 버퍼에 찬 만큼의 데이터 세그먼트를 보낸다.
        - write 속도가 네트워크 속도보다 빠르면 세그먼트 사이즈가 커진다.
        - write 속도보다 네트워크 상황이 좋으면 세그먼트 사이즈가 작아진다.
            - 오버헤드가 커지지만, 네트워크 상황이 좋기 때문에 괜찮다.
- 세그먼트 사이즈가 작으면
    - 수신측에서 데이터를 빨리 받을 수 있다.
        - 대신 네트워크에 과부하가 걸린다.

수신측의 동작
- 수신 버퍼 공간이 조금 남았어도 receive window 사이즈를 0으로 해서 ACK를 보냄
    - receive window가 작으면 송신측에서 비효율적인 세그먼트가 생성된다.
- 송신측에서 데이터를 크게 보낼 수 있게 보조해줌(receive window 사이즈를 0으로 함으로써)
- 바로 ACK를 보내지 않고 조금 기다렸다가 ACK 보내기
    - 데이터가 연달아서 오면 한 번에 ACK를 할 수 있음

connection management
- 소켓을 생성하고 해제하는 과정에 대한 설명
- 3-way-handshake를 통해 TCP를 맺는다.
    - 메시지가 3번 왔다 가야 TCP가 수립된다.
- 2-way가 아닌 이유
    - 만들자 -> 알았다
    - 수신측에서 송신측에 확답을 보냈지만 수신측은 송신측이 확답을 받았는지 확인할 수 없음
- 3-way-handshake
    - TCP 부분의 헤더 부분만 간다.
        - 송신측은 SYN 비트는 1로 설정되고, 최초의 SEQ 번호를 설정함
            - 헤더에 1비트 짜리 제어필드가 있다.
        - 수신측은 SYN = 1, ACK = 1, 자신의 SEQ 번호, ACK number 필드에는 송신측의 SEQ + 1 값을 설정해서 송신측에 전달
        - 송신측은 ACK = 1, ACK number 필드에는 수신측에서 전달한 SEQ + 1값을 설정
            - 위의 두 번의 단계는 헤더만 보내지만 이 단계에서는 헤더뿐만 아니라 데이터를 담아서 보낼 수 있다.(TCP 세그먼트로 사용)
- 연결 끊기
    - 애플리케이션 계층에서 close를 호출
    - 송신측에서 FIN = 1, SEQ 값을 보냄
    - 수신측은 ACK = 1, ACK number 값을 송신측에서 보낸 SEQ + 1 값을 설정해서 보낸다.
        - 보낼 데이터가 있으면 계속해서 데이터를 보냄
    - 데이터를 다 보냈다면 FIN = 1, SEQ 값을 보냄
    - 송신측도 ACK = 1, ACK number 값을 수신측에서 보낸 SEQ + 1 값을 설정해서 보낸다.
        - 보내고 바로 해제하지 않고 잠시 소켓을 열어둔다.
            - 송신측에서 마지막에 보낸 연결 끊기 응답(ACK = 1, ACKnum = seq + 1)이 유실될 수도 있기 때문임
            - FIN에 대한 ACK가 없으면 수신측의 타이머가 계속 동작해서 무한으로 FIN을 보내게 된다