## 네트워크 계층

현재는 IPv4 주소를 사용한다
- 32bit 사용
- 최대 2^32개의 호스트를 사용함
    - 약 40억개
    - globally unique한 주소를 가져야 함(식별할 수 있어야 하기 때문에)

IPv4의 주소의 고갈을 우려해 IPv6 공개
- 패킷 헤더의 존재하는 IP 주소 필드가 128bit임
    - 2^128개의 호스트를 지원 가능하다

현재도 IPv4 사용
- IPv4만 인식하는 라우터들을 IPv6도 인식하는 라우터 장비들로 교체해야 함
    - 이미 IPv4를 사용하는 생태계로 고정됨
- NAT(Network Address Translation)을 사용
    - 네트워크 내부에서 유일한 주소를 배정함
        - 다른 네트워크에서도 같은 주소를 사용할 수 있음(내부에서 사용)
        - 내부에서 외부로 데이터를 전송할 때 게이트웨이에서 네트워크의 유일한 주소로 변환해서 나간다.
        - 데이터가 내부로 들어올 때는 네트워크의 유일한 주소를 네트워크 내부에서 사용한 유일한 주소로 변환


NAT(Network Address Translation)
- IP는 globally unique 해야 한다.
    - 네트워크 내부에서만 유일한 IP 주소를 사용자에게 배정한다.
        - 네트워크 내부에서 외부로 나갈때 IP 주소를 게이트웨이(유니크함)의 IP 주소로 변환해준다.
        - 외부에서 내부로 들어올때도 IP를 변환 해준다.
- source : 10.0.0.1:3345 / Destination : 128.119.40.186:80
    - 이 데이터가 나갈때 게이트웨이에서 주소를 변경해줌
    - NAT translation table
        - WAN side addr : 128.76.29.7, 5001
        - LAN side addr : 10.0.0.1, 3345
        - NAT translation table 값을 이용해 주소를 변환해서 데이터를 서버에 전달하고 받은 응답에서 주소를 변환해서 매핑
        - IP주소뿐만 아니라 포트까지 변환해줌
            - 내부 IP 주소들은 유일함, 내부 주소 IP끼리 같은 포트를 사용한다면 NAT 테이블에서 어떤 호스트인지 모르므로 NAT 변환시 포트도 지정해준다.

집에서 공유기 사용시
- 통신사에서 IP 배정 -> 공유기에도 NAT 존재 -> 공유기가 각 사람들에게 IP 배정

NAT 부작용
- NAT 내부에서 서버 가동시
    - ex) 10.0.0.3:7777
    - 외부에서 접속할 수 없음(globally unique가 아니기 때문에)
    - 게이트웨이 IP 주소 알려줬을 때(128.76.29.7)
        - 게이트웨이 까지는 왔지만 테이블에 매핑된 값이 없다.
        - 클라이언트에서 외부서버로 갈때 매핑이 된다.
        - 서버는 외부에서 값이 들어온다.
        - 테이블에 매핑시켜놓으면 외부에서 접속이 가능하다.
            - holepunching이 가능하지만, 일반 사람들의 요청을 들어주지 않음
- 네트워크는 계층화가 되어있음, 각 계층은 다른 계층을 침범하면 안된다.
    - NAT에서 게이트웨이 라우터가 IP 패킷의 정보를 변경한다.(Source Address)
    - TCP의 포트번호까지 변경한다.(End to End(클라이언트, 서버)에서만 알 수있어야 됨)
- NAT에서 포트번호를 호스트를 구분하는데 사용함
    - 원래는 IP주소를 사용해야 함
    - 호스트번호는 네트워크 계층에서, TCP는 전송 계층에서 사용해야함
            
웹 사이트에서 특정 IP 차단
- NAT에서 세상에서는 개개인을 IP로 식별하기 힘들다.
    - IP차단시 그 NAT 내부 사용자들도 모두 차단됨
    - 개개인의 접속 ID를 이용한 차단

DHCP(Dynamic Host Configuration Protocol)
- Application 계층 프로토콜
- 고정 IP 방식 단점
    - 사용자에게 고정된 IP를 할당
    - IP 할당 수를 초과할 수 있다.
    - IP 풀 개수를 유지하고 필요한 사람이 있으면 그때그때 할당하는게 낫다.
        - DHCP 사용
- DHCP 서버
    - IP 주소를 배정해주는 서버
    - DHCP Client 포트번호 : 68, DHCP Server : 67
    - 클라이언트는 DHCP 클라이언트가 동작중이다.
    - 255.255.255.255:67 에서 255.255.255.255는 브로드캐스트임
        - source가 0.0.0.0:68인 이유는 자신의 IP 주소를 모르기 때문임
        - 서버내에 모두에게 전달
        - DHCP 서버는 67번 포트가 열려있으므로 메시지를 받아들임
        - DHCP서버가 응답할때는 255.255.255.255:68로 응답함
            - 클라이언트가 여러대일 경우 어떻게 식별하는가
            - transactionId로 식별
        - discover - offer외에도 연산이 있는 이유
            - DHCP 서버가 여러대일 경우
            - 여러 DHCP 서버 offer에 대해 하나를 선택해 request로 응답하기 위해.
            - offer에 대한 request가 브로드캐스트인 이유(255.255.255.255)
                - 다른 DHCP에도 알려주기 위해
- DHCP는 IP 뿐만 아니라 네트워크 접속에 필요한 다양한 정보를 알려줌
    - 내 IP 주소
    - 서브넷 마스크
    - 게이트웨이 라우터의 IP 주소
    - DNS서버의 IP 주소

IP 패킷 헤더
- 16-bit identifier
- flgs
- fragment offset
- 라우터마다 MTU(Maximum Transfer Unit)이 다르다.
    - 대른 라우터에서 MTU가 작으면 패킷이 쪼개진다.(fragment)
    - 쪼개진 패킷은 다시 조립되어야 한다.
    - 16-bit identifier, flgs, fragment offset을 이용해서 패킷을 재조립한다.
        - identifier = id
        - fragflag : 자신의 뒤에 재조립할 패킷이 있는지 있으면 1로
            - 맨 마지막 패킷은 0으로 설정
        - offset
            - 시작 바이트 / 8 값이 들어감 
            - ex 1489 / 8, 2960 / 8
            - 패킷을 크기를 줄이려고 나눈다.

예시 

4000 바이트의 패킷이 MTU가 1500바이트인 라우터를 만남

length = 4000, id = x, fragflag = 0, offset = 0
- 헤더는 20바이트기 때문에, 데이터는 3980
- fragflag 뒤에 fragment된게 있으면 1로 표시한다.
- 오프셋(offset)은 fragmented 되기 전에 위치를 말한다.

length = 1500, id = x, fragflag = 1, offset = 0<br>
length = 1500, id = x, fragflag = 1, offset = 185<br>
length = 1040, id = x, fragflag = 0, offset = 370<br>

(1480 + 1480 + 1020) => 헤더부분을 뺴야 하므로

185는 1480 / 8의 값임<br>
370은 2960 / 8의 값임