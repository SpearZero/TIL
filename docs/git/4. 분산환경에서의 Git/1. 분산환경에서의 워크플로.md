> https://git-scm.com/book/ko/v2/%EB%B6%84%EC%82%B0-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C%EC%9D%98-Git-%EB%B6%84%EC%82%B0-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C%EC%9D%98-%EC%9B%8C%ED%81%AC%ED%94%8C%EB%A1%9C
## 분산 환경에서의 워크플로
### 중앙집중식 워크플로
중앙 저장소는 딱 하나 있고 변경 사항은 모두 이 저장소에 집중된다.<br>
![centralized-workflow](./pic/centralized_workflow.png)<br>
중앙 집중에서 여러 개발자가 중앙저장소를 Clone하고 각자 수정했을시, 한 개발자가 자신의 수정 사항을 커밋하고 서버에<br> Push 했다면 다른 개발자는 자신의 수정 내용을 서버에 Push 하기 전에 자신의 앞 개발자가 Push한 내용을 Merge해야한다.<br> Merge를 해야 첫 번째 작업자가 작업한 내용을 덮어쓰지 않는다.<br>
팀이 작거나 이미 중앙집중식에 적응한 상황이라면 이 워크플로에 따라 Git을 도입하여 사용할 수 있다. 중앙저장소를 하나<br> 만들고 개발자모두에게 Push 권한을 부여한다. 모두에게 Push 권한을 부여해도 Git은 한 개발자가 다른 개발자의 작업 내용을<br> 덮어쓰도록 허용하지 않는다.

### Integration-Manager 워크플로
기여자는 공식 저장소를 Clone하고 자신이 작업한 내용을 자신의 저장소에 Push한다. 그리고 프로젝트 Integration-Manager<br> 에게 자신의 저장소를 Pull하라고 요청한다. Integration-Manager는 기여자의 저장소를 리모트 저장소로 등록하고, 로컬에서<br> 기여물을 테스트하고, 프로젝트의 메인 브랜치에 Merge하고 메인 저장소에 Push한다.<br>
![integration-mananger](./pic/integration-manager.png)<br>
이 구조의 장점은 기여자와 Integration-Manager가 각각의 사정에 맞춰 프로젝트를 유지할 수 있다. 기여자는 자신의 저장소와<br> 브랜치에서 수정 작업을 계속해 나갈 수 있고 수정사항이 프로젝트에 반영되도록 기다릴 필요가 없다. 관리자는 여유를 가지고<br> 기여자가 Push 해놓은 커밋을 적절한 시점에 Merge한다.

### Dictator and Lieutenants 구조
이 방식은 저장소를 여러개 운영하는 방식을 변형한 것이다. 아주 큰 프로젝트를 운영할 때 사용하는 방법이다(예: Linux).<br> 여러명의 Integration-Manager가 저장소에서 자신이 맡은 부분만을 담당하는데 이들을 Lieutenatns라고 부른다.<br> 모든 Lieutenants는 최종 관리자 아래에 있으며 이 최종 관리자를 Benevolent Dictator라고 부른다. Benevolent Dicator는<br> Lietenats의 저장소를 가져와 공식 저장소에 Push하고 모든 프로젝트 참여자는 이 공식 저장소에서 반드시 Pull 해야 한다.<br>
 ![benevolent-dictator](./pic/benevolent-dictator.png)<br>
 
